<?php
/**
 * ManagementApi
 * PHP version 5
 *
 * @category Class
 * @package  TalonOne\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Talon.One API
 *
 * The Talon.One API is used to manage applications and campaigns, as well as to integrate with your application. The operations in the _Integration API_ section are used to integrate with our platform, while the other operations are used to manage applications and campaigns.  ### Where is the API?  The API is available at the same hostname as these docs. For example, if you are reading this page at `https://mycompany.talon.one/docs/api/`, the URL for the [updateCustomerProfile][] operation is `https://mycompany.talon.one/v1/customer_profiles/id`  [updateCustomerProfile]: #operation--v1-customer_profiles--integrationId--put
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.2.3
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace TalonOne\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use TalonOne\Client\ApiException;
use TalonOne\Client\Configuration;
use TalonOne\Client\HeaderSelector;
use TalonOne\Client\ObjectSerializer;

/**
 * ManagementApi Class Doc Comment
 *
 * @category Class
 * @package  TalonOne\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ManagementApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addLoyaltyPoints
     *
     * Add points in a certain loyalty program for the specified customer
     *
     * @param  string $program_id program_id (required)
     * @param  string $integration_id integration_id (required)
     * @param  \TalonOne\Client\Model\LoyaltyPoints $body body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function addLoyaltyPoints($program_id, $integration_id, $body)
    {
        $this->addLoyaltyPointsWithHttpInfo($program_id, $integration_id, $body);
    }

    /**
     * Operation addLoyaltyPointsWithHttpInfo
     *
     * Add points in a certain loyalty program for the specified customer
     *
     * @param  string $program_id (required)
     * @param  string $integration_id (required)
     * @param  \TalonOne\Client\Model\LoyaltyPoints $body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function addLoyaltyPointsWithHttpInfo($program_id, $integration_id, $body)
    {
        $request = $this->addLoyaltyPointsRequest($program_id, $integration_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation addLoyaltyPointsAsync
     *
     * Add points in a certain loyalty program for the specified customer
     *
     * @param  string $program_id (required)
     * @param  string $integration_id (required)
     * @param  \TalonOne\Client\Model\LoyaltyPoints $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addLoyaltyPointsAsync($program_id, $integration_id, $body)
    {
        return $this->addLoyaltyPointsAsyncWithHttpInfo($program_id, $integration_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addLoyaltyPointsAsyncWithHttpInfo
     *
     * Add points in a certain loyalty program for the specified customer
     *
     * @param  string $program_id (required)
     * @param  string $integration_id (required)
     * @param  \TalonOne\Client\Model\LoyaltyPoints $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addLoyaltyPointsAsyncWithHttpInfo($program_id, $integration_id, $body)
    {
        $returnType = '';
        $request = $this->addLoyaltyPointsRequest($program_id, $integration_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addLoyaltyPoints'
     *
     * @param  string $program_id (required)
     * @param  string $integration_id (required)
     * @param  \TalonOne\Client\Model\LoyaltyPoints $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addLoyaltyPointsRequest($program_id, $integration_id, $body)
    {
        // verify the required parameter 'program_id' is set
        if ($program_id === null || (is_array($program_id) && count($program_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $program_id when calling addLoyaltyPoints'
            );
        }
        // verify the required parameter 'integration_id' is set
        if ($integration_id === null || (is_array($integration_id) && count($integration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $integration_id when calling addLoyaltyPoints'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling addLoyaltyPoints'
            );
        }

        $resourcePath = '/v1/loyalty_programs/{programID}/profile/{integrationID}/add_points';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($program_id !== null) {
            $resourcePath = str_replace(
                '{' . 'programID' . '}',
                ObjectSerializer::toPathValue($program_id),
                $resourcePath
            );
        }
        // path params
        if ($integration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'integrationID' . '}',
                ObjectSerializer::toPathValue($integration_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation copyCampaignToApplications
     *
     * Copy the campaign into every specified application
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  \TalonOne\Client\Model\CampaignCopy $body body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse2003
     */
    public function copyCampaignToApplications($application_id, $campaign_id, $body)
    {
        list($response) = $this->copyCampaignToApplicationsWithHttpInfo($application_id, $campaign_id, $body);
        return $response;
    }

    /**
     * Operation copyCampaignToApplicationsWithHttpInfo
     *
     * Copy the campaign into every specified application
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\CampaignCopy $body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function copyCampaignToApplicationsWithHttpInfo($application_id, $campaign_id, $body)
    {
        $request = $this->copyCampaignToApplicationsRequest($application_id, $campaign_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse2003' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse2003', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse2003';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse2003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation copyCampaignToApplicationsAsync
     *
     * Copy the campaign into every specified application
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\CampaignCopy $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyCampaignToApplicationsAsync($application_id, $campaign_id, $body)
    {
        return $this->copyCampaignToApplicationsAsyncWithHttpInfo($application_id, $campaign_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation copyCampaignToApplicationsAsyncWithHttpInfo
     *
     * Copy the campaign into every specified application
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\CampaignCopy $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyCampaignToApplicationsAsyncWithHttpInfo($application_id, $campaign_id, $body)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse2003';
        $request = $this->copyCampaignToApplicationsRequest($application_id, $campaign_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'copyCampaignToApplications'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\CampaignCopy $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function copyCampaignToApplicationsRequest($application_id, $campaign_id, $body)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling copyCampaignToApplications'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling copyCampaignToApplications'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling copyCampaignToApplications'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}/copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAdditionalCost
     *
     * Define a new additional cost
     *
     * @param  \TalonOne\Client\Model\NewAdditionalCost $body body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\AccountAdditionalCost
     */
    public function createAdditionalCost($body)
    {
        list($response) = $this->createAdditionalCostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createAdditionalCostWithHttpInfo
     *
     * Define a new additional cost
     *
     * @param  \TalonOne\Client\Model\NewAdditionalCost $body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\AccountAdditionalCost, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAdditionalCostWithHttpInfo($body)
    {
        $request = $this->createAdditionalCostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 201:
                    if ('\TalonOne\Client\Model\AccountAdditionalCost' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\AccountAdditionalCost', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\AccountAdditionalCost';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\AccountAdditionalCost',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAdditionalCostAsync
     *
     * Define a new additional cost
     *
     * @param  \TalonOne\Client\Model\NewAdditionalCost $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAdditionalCostAsync($body)
    {
        return $this->createAdditionalCostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAdditionalCostAsyncWithHttpInfo
     *
     * Define a new additional cost
     *
     * @param  \TalonOne\Client\Model\NewAdditionalCost $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAdditionalCostAsyncWithHttpInfo($body)
    {
        $returnType = '\TalonOne\Client\Model\AccountAdditionalCost';
        $request = $this->createAdditionalCostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAdditionalCost'
     *
     * @param  \TalonOne\Client\Model\NewAdditionalCost $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createAdditionalCostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createAdditionalCost'
            );
        }

        $resourcePath = '/v1/additional_costs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAttribute
     *
     * Define a new custom attribute
     *
     * @param  \TalonOne\Client\Model\NewAttribute $body body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\Attribute
     */
    public function createAttribute($body)
    {
        list($response) = $this->createAttributeWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createAttributeWithHttpInfo
     *
     * Define a new custom attribute
     *
     * @param  \TalonOne\Client\Model\NewAttribute $body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\Attribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAttributeWithHttpInfo($body)
    {
        $request = $this->createAttributeRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 201:
                    if ('\TalonOne\Client\Model\Attribute' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\Attribute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\Attribute';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\Attribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAttributeAsync
     *
     * Define a new custom attribute
     *
     * @param  \TalonOne\Client\Model\NewAttribute $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAttributeAsync($body)
    {
        return $this->createAttributeAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAttributeAsyncWithHttpInfo
     *
     * Define a new custom attribute
     *
     * @param  \TalonOne\Client\Model\NewAttribute $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAttributeAsyncWithHttpInfo($body)
    {
        $returnType = '\TalonOne\Client\Model\Attribute';
        $request = $this->createAttributeRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAttribute'
     *
     * @param  \TalonOne\Client\Model\NewAttribute $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createAttributeRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createAttribute'
            );
        }

        $resourcePath = '/v1/attributes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCampaign
     *
     * Create a Campaign
     *
     * @param  int $application_id application_id (required)
     * @param  \TalonOne\Client\Model\NewCampaign $body body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\Campaign
     */
    public function createCampaign($application_id, $body)
    {
        list($response) = $this->createCampaignWithHttpInfo($application_id, $body);
        return $response;
    }

    /**
     * Operation createCampaignWithHttpInfo
     *
     * Create a Campaign
     *
     * @param  int $application_id (required)
     * @param  \TalonOne\Client\Model\NewCampaign $body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\Campaign, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCampaignWithHttpInfo($application_id, $body)
    {
        $request = $this->createCampaignRequest($application_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 201:
                    if ('\TalonOne\Client\Model\Campaign' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\Campaign', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\Campaign';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\Campaign',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCampaignAsync
     *
     * Create a Campaign
     *
     * @param  int $application_id (required)
     * @param  \TalonOne\Client\Model\NewCampaign $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCampaignAsync($application_id, $body)
    {
        return $this->createCampaignAsyncWithHttpInfo($application_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCampaignAsyncWithHttpInfo
     *
     * Create a Campaign
     *
     * @param  int $application_id (required)
     * @param  \TalonOne\Client\Model\NewCampaign $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCampaignAsyncWithHttpInfo($application_id, $body)
    {
        $returnType = '\TalonOne\Client\Model\Campaign';
        $request = $this->createCampaignRequest($application_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCampaign'
     *
     * @param  int $application_id (required)
     * @param  \TalonOne\Client\Model\NewCampaign $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createCampaignRequest($application_id, $body)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling createCampaign'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createCampaign'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCoupons
     *
     * Create Coupons
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  \TalonOne\Client\Model\NewCoupons $body body (required)
     * @param  string $silent If set to &#39;yes&#39;, response will be an empty 204, otherwise a list of the coupons generated (to to 1000). (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse2001
     */
    public function createCoupons($application_id, $campaign_id, $body, $silent = null)
    {
        list($response) = $this->createCouponsWithHttpInfo($application_id, $campaign_id, $body, $silent);
        return $response;
    }

    /**
     * Operation createCouponsWithHttpInfo
     *
     * Create Coupons
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\NewCoupons $body (required)
     * @param  string $silent If set to &#39;yes&#39;, response will be an empty 204, otherwise a list of the coupons generated (to to 1000). (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCouponsWithHttpInfo($application_id, $campaign_id, $body, $silent = null)
    {
        $request = $this->createCouponsRequest($application_id, $campaign_id, $body, $silent);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse2001' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse2001', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse2001';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse2001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCouponsAsync
     *
     * Create Coupons
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\NewCoupons $body (required)
     * @param  string $silent If set to &#39;yes&#39;, response will be an empty 204, otherwise a list of the coupons generated (to to 1000). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCouponsAsync($application_id, $campaign_id, $body, $silent = null)
    {
        return $this->createCouponsAsyncWithHttpInfo($application_id, $campaign_id, $body, $silent)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCouponsAsyncWithHttpInfo
     *
     * Create Coupons
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\NewCoupons $body (required)
     * @param  string $silent If set to &#39;yes&#39;, response will be an empty 204, otherwise a list of the coupons generated (to to 1000). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCouponsAsyncWithHttpInfo($application_id, $campaign_id, $body, $silent = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse2001';
        $request = $this->createCouponsRequest($application_id, $campaign_id, $body, $silent);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCoupons'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\NewCoupons $body (required)
     * @param  string $silent If set to &#39;yes&#39;, response will be an empty 204, otherwise a list of the coupons generated (to to 1000). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createCouponsRequest($application_id, $campaign_id, $body, $silent = null)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling createCoupons'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling createCoupons'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createCoupons'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($silent !== null) {
            $queryParams['silent'] = ObjectSerializer::toQueryValue($silent);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPasswordRecoveryEmail
     *
     * Request a password reset
     *
     * @param  \TalonOne\Client\Model\NewPasswordEmail $body body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\NewPasswordEmail
     */
    public function createPasswordRecoveryEmail($body)
    {
        list($response) = $this->createPasswordRecoveryEmailWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createPasswordRecoveryEmailWithHttpInfo
     *
     * Request a password reset
     *
     * @param  \TalonOne\Client\Model\NewPasswordEmail $body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\NewPasswordEmail, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPasswordRecoveryEmailWithHttpInfo($body)
    {
        $request = $this->createPasswordRecoveryEmailRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 204:
                    if ('\TalonOne\Client\Model\NewPasswordEmail' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\NewPasswordEmail', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\NewPasswordEmail';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\NewPasswordEmail',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPasswordRecoveryEmailAsync
     *
     * Request a password reset
     *
     * @param  \TalonOne\Client\Model\NewPasswordEmail $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPasswordRecoveryEmailAsync($body)
    {
        return $this->createPasswordRecoveryEmailAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPasswordRecoveryEmailAsyncWithHttpInfo
     *
     * Request a password reset
     *
     * @param  \TalonOne\Client\Model\NewPasswordEmail $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPasswordRecoveryEmailAsyncWithHttpInfo($body)
    {
        $returnType = '\TalonOne\Client\Model\NewPasswordEmail';
        $request = $this->createPasswordRecoveryEmailRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPasswordRecoveryEmail'
     *
     * @param  \TalonOne\Client\Model\NewPasswordEmail $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createPasswordRecoveryEmailRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createPasswordRecoveryEmail'
            );
        }

        $resourcePath = '/v1/password_recovery_emails';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRuleset
     *
     * Create a Ruleset
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  \TalonOne\Client\Model\NewRuleset $body body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\Ruleset
     */
    public function createRuleset($application_id, $campaign_id, $body)
    {
        list($response) = $this->createRulesetWithHttpInfo($application_id, $campaign_id, $body);
        return $response;
    }

    /**
     * Operation createRulesetWithHttpInfo
     *
     * Create a Ruleset
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\NewRuleset $body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\Ruleset, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRulesetWithHttpInfo($application_id, $campaign_id, $body)
    {
        $request = $this->createRulesetRequest($application_id, $campaign_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 201:
                    if ('\TalonOne\Client\Model\Ruleset' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\Ruleset', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\Ruleset';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\Ruleset',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createRulesetAsync
     *
     * Create a Ruleset
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\NewRuleset $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRulesetAsync($application_id, $campaign_id, $body)
    {
        return $this->createRulesetAsyncWithHttpInfo($application_id, $campaign_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRulesetAsyncWithHttpInfo
     *
     * Create a Ruleset
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\NewRuleset $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRulesetAsyncWithHttpInfo($application_id, $campaign_id, $body)
    {
        $returnType = '\TalonOne\Client\Model\Ruleset';
        $request = $this->createRulesetRequest($application_id, $campaign_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRuleset'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\NewRuleset $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createRulesetRequest($application_id, $campaign_id, $body)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling createRuleset'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling createRuleset'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createRuleset'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createSession
     *
     * Create a Session
     *
     * @param  \TalonOne\Client\Model\LoginParams $body body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\Session
     */
    public function createSession($body)
    {
        list($response) = $this->createSessionWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createSessionWithHttpInfo
     *
     * Create a Session
     *
     * @param  \TalonOne\Client\Model\LoginParams $body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\Session, HTTP status code, HTTP response headers (array of strings)
     */
    public function createSessionWithHttpInfo($body)
    {
        $request = $this->createSessionRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 201:
                    if ('\TalonOne\Client\Model\Session' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\Session', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\Session';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\Session',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createSessionAsync
     *
     * Create a Session
     *
     * @param  \TalonOne\Client\Model\LoginParams $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSessionAsync($body)
    {
        return $this->createSessionAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createSessionAsyncWithHttpInfo
     *
     * Create a Session
     *
     * @param  \TalonOne\Client\Model\LoginParams $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSessionAsyncWithHttpInfo($body)
    {
        $returnType = '\TalonOne\Client\Model\Session';
        $request = $this->createSessionRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createSession'
     *
     * @param  \TalonOne\Client\Model\LoginParams $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createSessionRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createSession'
            );
        }

        $resourcePath = '/v1/sessions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCampaign
     *
     * Delete a Campaign
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCampaign($application_id, $campaign_id)
    {
        $this->deleteCampaignWithHttpInfo($application_id, $campaign_id);
    }

    /**
     * Operation deleteCampaignWithHttpInfo
     *
     * Delete a Campaign
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCampaignWithHttpInfo($application_id, $campaign_id)
    {
        $request = $this->deleteCampaignRequest($application_id, $campaign_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCampaignAsync
     *
     * Delete a Campaign
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCampaignAsync($application_id, $campaign_id)
    {
        return $this->deleteCampaignAsyncWithHttpInfo($application_id, $campaign_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCampaignAsyncWithHttpInfo
     *
     * Delete a Campaign
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCampaignAsyncWithHttpInfo($application_id, $campaign_id)
    {
        $returnType = '';
        $request = $this->deleteCampaignRequest($application_id, $campaign_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCampaign'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCampaignRequest($application_id, $campaign_id)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling deleteCampaign'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling deleteCampaign'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCoupon
     *
     * Delete one Coupon
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  string $coupon_id The ID of the coupon code to delete (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCoupon($application_id, $campaign_id, $coupon_id)
    {
        $this->deleteCouponWithHttpInfo($application_id, $campaign_id, $coupon_id);
    }

    /**
     * Operation deleteCouponWithHttpInfo
     *
     * Delete one Coupon
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  string $coupon_id The ID of the coupon code to delete (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCouponWithHttpInfo($application_id, $campaign_id, $coupon_id)
    {
        $request = $this->deleteCouponRequest($application_id, $campaign_id, $coupon_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCouponAsync
     *
     * Delete one Coupon
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  string $coupon_id The ID of the coupon code to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCouponAsync($application_id, $campaign_id, $coupon_id)
    {
        return $this->deleteCouponAsyncWithHttpInfo($application_id, $campaign_id, $coupon_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCouponAsyncWithHttpInfo
     *
     * Delete one Coupon
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  string $coupon_id The ID of the coupon code to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCouponAsyncWithHttpInfo($application_id, $campaign_id, $coupon_id)
    {
        $returnType = '';
        $request = $this->deleteCouponRequest($application_id, $campaign_id, $coupon_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCoupon'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  string $coupon_id The ID of the coupon code to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCouponRequest($application_id, $campaign_id, $coupon_id)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling deleteCoupon'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling deleteCoupon'
            );
        }
        // verify the required parameter 'coupon_id' is set
        if ($coupon_id === null || (is_array($coupon_id) && count($coupon_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $coupon_id when calling deleteCoupon'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons/{couponId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }
        // path params
        if ($coupon_id !== null) {
            $resourcePath = str_replace(
                '{' . 'couponId' . '}',
                ObjectSerializer::toPathValue($coupon_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCoupons
     *
     * Delete Coupons
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $starts_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $starts_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $expires_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $expires_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCoupons($application_id, $campaign_id, $value = null, $created_before = null, $created_after = null, $starts_after = null, $starts_before = null, $expires_after = null, $expires_before = null, $valid = null, $batch_id = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false)
    {
        $this->deleteCouponsWithHttpInfo($application_id, $campaign_id, $value, $created_before, $created_after, $starts_after, $starts_before, $expires_after, $expires_before, $valid, $batch_id, $usable, $referral_id, $recipient_integration_id, $exact_match);
    }

    /**
     * Operation deleteCouponsWithHttpInfo
     *
     * Delete Coupons
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $starts_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $starts_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $expires_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $expires_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCouponsWithHttpInfo($application_id, $campaign_id, $value = null, $created_before = null, $created_after = null, $starts_after = null, $starts_before = null, $expires_after = null, $expires_before = null, $valid = null, $batch_id = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false)
    {
        $request = $this->deleteCouponsRequest($application_id, $campaign_id, $value, $created_before, $created_after, $starts_after, $starts_before, $expires_after, $expires_before, $valid, $batch_id, $usable, $referral_id, $recipient_integration_id, $exact_match);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCouponsAsync
     *
     * Delete Coupons
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $starts_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $starts_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $expires_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $expires_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCouponsAsync($application_id, $campaign_id, $value = null, $created_before = null, $created_after = null, $starts_after = null, $starts_before = null, $expires_after = null, $expires_before = null, $valid = null, $batch_id = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false)
    {
        return $this->deleteCouponsAsyncWithHttpInfo($application_id, $campaign_id, $value, $created_before, $created_after, $starts_after, $starts_before, $expires_after, $expires_before, $valid, $batch_id, $usable, $referral_id, $recipient_integration_id, $exact_match)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCouponsAsyncWithHttpInfo
     *
     * Delete Coupons
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $starts_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $starts_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $expires_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $expires_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCouponsAsyncWithHttpInfo($application_id, $campaign_id, $value = null, $created_before = null, $created_after = null, $starts_after = null, $starts_before = null, $expires_after = null, $expires_before = null, $valid = null, $batch_id = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false)
    {
        $returnType = '';
        $request = $this->deleteCouponsRequest($application_id, $campaign_id, $value, $created_before, $created_after, $starts_after, $starts_before, $expires_after, $expires_before, $valid, $batch_id, $usable, $referral_id, $recipient_integration_id, $exact_match);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCoupons'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $starts_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $starts_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $expires_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $expires_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCouponsRequest($application_id, $campaign_id, $value = null, $created_before = null, $created_after = null, $starts_after = null, $starts_before = null, $expires_after = null, $expires_before = null, $valid = null, $batch_id = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling deleteCoupons'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling deleteCoupons'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($value !== null) {
            $queryParams['value'] = ObjectSerializer::toQueryValue($value);
        }
        // query params
        if ($created_before !== null) {
            $queryParams['createdBefore'] = ObjectSerializer::toQueryValue($created_before);
        }
        // query params
        if ($created_after !== null) {
            $queryParams['createdAfter'] = ObjectSerializer::toQueryValue($created_after);
        }
        // query params
        if ($starts_after !== null) {
            $queryParams['startsAfter'] = ObjectSerializer::toQueryValue($starts_after);
        }
        // query params
        if ($starts_before !== null) {
            $queryParams['startsBefore'] = ObjectSerializer::toQueryValue($starts_before);
        }
        // query params
        if ($expires_after !== null) {
            $queryParams['expiresAfter'] = ObjectSerializer::toQueryValue($expires_after);
        }
        // query params
        if ($expires_before !== null) {
            $queryParams['expiresBefore'] = ObjectSerializer::toQueryValue($expires_before);
        }
        // query params
        if ($valid !== null) {
            $queryParams['valid'] = ObjectSerializer::toQueryValue($valid);
        }
        // query params
        if ($batch_id !== null) {
            $queryParams['batchId'] = ObjectSerializer::toQueryValue($batch_id);
        }
        // query params
        if ($usable !== null) {
            $queryParams['usable'] = ObjectSerializer::toQueryValue($usable);
        }
        // query params
        if ($referral_id !== null) {
            $queryParams['referralId'] = ObjectSerializer::toQueryValue($referral_id);
        }
        // query params
        if ($recipient_integration_id !== null) {
            $queryParams['recipientIntegrationId'] = ObjectSerializer::toQueryValue($recipient_integration_id);
        }
        // query params
        if ($exact_match !== null) {
            $queryParams['exactMatch'] = ObjectSerializer::toQueryValue($exact_match);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteReferral
     *
     * Delete one Referral
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  string $referral_id The ID of the referral code to delete (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteReferral($application_id, $campaign_id, $referral_id)
    {
        $this->deleteReferralWithHttpInfo($application_id, $campaign_id, $referral_id);
    }

    /**
     * Operation deleteReferralWithHttpInfo
     *
     * Delete one Referral
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  string $referral_id The ID of the referral code to delete (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteReferralWithHttpInfo($application_id, $campaign_id, $referral_id)
    {
        $request = $this->deleteReferralRequest($application_id, $campaign_id, $referral_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteReferralAsync
     *
     * Delete one Referral
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  string $referral_id The ID of the referral code to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteReferralAsync($application_id, $campaign_id, $referral_id)
    {
        return $this->deleteReferralAsyncWithHttpInfo($application_id, $campaign_id, $referral_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteReferralAsyncWithHttpInfo
     *
     * Delete one Referral
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  string $referral_id The ID of the referral code to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteReferralAsyncWithHttpInfo($application_id, $campaign_id, $referral_id)
    {
        $returnType = '';
        $request = $this->deleteReferralRequest($application_id, $campaign_id, $referral_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteReferral'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  string $referral_id The ID of the referral code to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteReferralRequest($application_id, $campaign_id, $referral_id)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling deleteReferral'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling deleteReferral'
            );
        }
        // verify the required parameter 'referral_id' is set
        if ($referral_id === null || (is_array($referral_id) && count($referral_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $referral_id when calling deleteReferral'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}/referrals/{referralId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }
        // path params
        if ($referral_id !== null) {
            $resourcePath = str_replace(
                '{' . 'referralId' . '}',
                ObjectSerializer::toPathValue($referral_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRuleset
     *
     * Delete a Ruleset
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  int $ruleset_id ruleset_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRuleset($application_id, $campaign_id, $ruleset_id)
    {
        $this->deleteRulesetWithHttpInfo($application_id, $campaign_id, $ruleset_id);
    }

    /**
     * Operation deleteRulesetWithHttpInfo
     *
     * Delete a Ruleset
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $ruleset_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRulesetWithHttpInfo($application_id, $campaign_id, $ruleset_id)
    {
        $request = $this->deleteRulesetRequest($application_id, $campaign_id, $ruleset_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRulesetAsync
     *
     * Delete a Ruleset
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $ruleset_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRulesetAsync($application_id, $campaign_id, $ruleset_id)
    {
        return $this->deleteRulesetAsyncWithHttpInfo($application_id, $campaign_id, $ruleset_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRulesetAsyncWithHttpInfo
     *
     * Delete a Ruleset
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $ruleset_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRulesetAsyncWithHttpInfo($application_id, $campaign_id, $ruleset_id)
    {
        $returnType = '';
        $request = $this->deleteRulesetRequest($application_id, $campaign_id, $ruleset_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRuleset'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $ruleset_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteRulesetRequest($application_id, $campaign_id, $ruleset_id)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling deleteRuleset'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling deleteRuleset'
            );
        }
        // verify the required parameter 'ruleset_id' is set
        if ($ruleset_id === null || (is_array($ruleset_id) && count($ruleset_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ruleset_id when calling deleteRuleset'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets/{rulesetId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }
        // path params
        if ($ruleset_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rulesetId' . '}',
                ObjectSerializer::toPathValue($ruleset_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccessLogs
     *
     * Get access logs for application
     *
     * @param  int $application_id application_id (required)
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  string $path Only return results where the request path matches the given regular expression. (optional)
     * @param  string $method Only return results where the request method matches the given regular expression. (optional)
     * @param  string $status Filter results by HTTP status codes. (optional)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse2009
     */
    public function getAccessLogs($application_id, $range_start, $range_end, $path = null, $method = null, $status = null, $page_size = null, $skip = null, $sort = null)
    {
        list($response) = $this->getAccessLogsWithHttpInfo($application_id, $range_start, $range_end, $path, $method, $status, $page_size, $skip, $sort);
        return $response;
    }

    /**
     * Operation getAccessLogsWithHttpInfo
     *
     * Get access logs for application
     *
     * @param  int $application_id (required)
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  string $path Only return results where the request path matches the given regular expression. (optional)
     * @param  string $method Only return results where the request method matches the given regular expression. (optional)
     * @param  string $status Filter results by HTTP status codes. (optional)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse2009, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccessLogsWithHttpInfo($application_id, $range_start, $range_end, $path = null, $method = null, $status = null, $page_size = null, $skip = null, $sort = null)
    {
        $request = $this->getAccessLogsRequest($application_id, $range_start, $range_end, $path, $method, $status, $page_size, $skip, $sort);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse2009' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse2009', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse2009';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse2009',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccessLogsAsync
     *
     * Get access logs for application
     *
     * @param  int $application_id (required)
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  string $path Only return results where the request path matches the given regular expression. (optional)
     * @param  string $method Only return results where the request method matches the given regular expression. (optional)
     * @param  string $status Filter results by HTTP status codes. (optional)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccessLogsAsync($application_id, $range_start, $range_end, $path = null, $method = null, $status = null, $page_size = null, $skip = null, $sort = null)
    {
        return $this->getAccessLogsAsyncWithHttpInfo($application_id, $range_start, $range_end, $path, $method, $status, $page_size, $skip, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccessLogsAsyncWithHttpInfo
     *
     * Get access logs for application
     *
     * @param  int $application_id (required)
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  string $path Only return results where the request path matches the given regular expression. (optional)
     * @param  string $method Only return results where the request method matches the given regular expression. (optional)
     * @param  string $status Filter results by HTTP status codes. (optional)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccessLogsAsyncWithHttpInfo($application_id, $range_start, $range_end, $path = null, $method = null, $status = null, $page_size = null, $skip = null, $sort = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse2009';
        $request = $this->getAccessLogsRequest($application_id, $range_start, $range_end, $path, $method, $status, $page_size, $skip, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccessLogs'
     *
     * @param  int $application_id (required)
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  string $path Only return results where the request path matches the given regular expression. (optional)
     * @param  string $method Only return results where the request method matches the given regular expression. (optional)
     * @param  string $status Filter results by HTTP status codes. (optional)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAccessLogsRequest($application_id, $range_start, $range_end, $path = null, $method = null, $status = null, $page_size = null, $skip = null, $sort = null)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getAccessLogs'
            );
        }
        // verify the required parameter 'range_start' is set
        if ($range_start === null || (is_array($range_start) && count($range_start) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $range_start when calling getAccessLogs'
            );
        }
        // verify the required parameter 'range_end' is set
        if ($range_end === null || (is_array($range_end) && count($range_end) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $range_end when calling getAccessLogs'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/access_logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($method !== null) {
            $queryParams['method'] = ObjectSerializer::toQueryValue($method);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($range_start !== null) {
            $queryParams['rangeStart'] = ObjectSerializer::toQueryValue($range_start);
        }
        // query params
        if ($range_end !== null) {
            $queryParams['rangeEnd'] = ObjectSerializer::toQueryValue($range_end);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccessLogsWithoutTotalCount
     *
     * Get access logs for application
     *
     * @param  int $application_id application_id (required)
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  string $path Only return results where the request path matches the given regular expression. (optional)
     * @param  string $method Only return results where the request method matches the given regular expression. (optional)
     * @param  string $status Filter results by HTTP status codes. (optional)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20010
     */
    public function getAccessLogsWithoutTotalCount($application_id, $range_start, $range_end, $path = null, $method = null, $status = null, $page_size = null, $skip = null, $sort = null)
    {
        list($response) = $this->getAccessLogsWithoutTotalCountWithHttpInfo($application_id, $range_start, $range_end, $path, $method, $status, $page_size, $skip, $sort);
        return $response;
    }

    /**
     * Operation getAccessLogsWithoutTotalCountWithHttpInfo
     *
     * Get access logs for application
     *
     * @param  int $application_id (required)
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  string $path Only return results where the request path matches the given regular expression. (optional)
     * @param  string $method Only return results where the request method matches the given regular expression. (optional)
     * @param  string $status Filter results by HTTP status codes. (optional)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20010, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccessLogsWithoutTotalCountWithHttpInfo($application_id, $range_start, $range_end, $path = null, $method = null, $status = null, $page_size = null, $skip = null, $sort = null)
    {
        $request = $this->getAccessLogsWithoutTotalCountRequest($application_id, $range_start, $range_end, $path, $method, $status, $page_size, $skip, $sort);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20010' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20010', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20010';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20010',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccessLogsWithoutTotalCountAsync
     *
     * Get access logs for application
     *
     * @param  int $application_id (required)
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  string $path Only return results where the request path matches the given regular expression. (optional)
     * @param  string $method Only return results where the request method matches the given regular expression. (optional)
     * @param  string $status Filter results by HTTP status codes. (optional)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccessLogsWithoutTotalCountAsync($application_id, $range_start, $range_end, $path = null, $method = null, $status = null, $page_size = null, $skip = null, $sort = null)
    {
        return $this->getAccessLogsWithoutTotalCountAsyncWithHttpInfo($application_id, $range_start, $range_end, $path, $method, $status, $page_size, $skip, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccessLogsWithoutTotalCountAsyncWithHttpInfo
     *
     * Get access logs for application
     *
     * @param  int $application_id (required)
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  string $path Only return results where the request path matches the given regular expression. (optional)
     * @param  string $method Only return results where the request method matches the given regular expression. (optional)
     * @param  string $status Filter results by HTTP status codes. (optional)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccessLogsWithoutTotalCountAsyncWithHttpInfo($application_id, $range_start, $range_end, $path = null, $method = null, $status = null, $page_size = null, $skip = null, $sort = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20010';
        $request = $this->getAccessLogsWithoutTotalCountRequest($application_id, $range_start, $range_end, $path, $method, $status, $page_size, $skip, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccessLogsWithoutTotalCount'
     *
     * @param  int $application_id (required)
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  string $path Only return results where the request path matches the given regular expression. (optional)
     * @param  string $method Only return results where the request method matches the given regular expression. (optional)
     * @param  string $status Filter results by HTTP status codes. (optional)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAccessLogsWithoutTotalCountRequest($application_id, $range_start, $range_end, $path = null, $method = null, $status = null, $page_size = null, $skip = null, $sort = null)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getAccessLogsWithoutTotalCount'
            );
        }
        // verify the required parameter 'range_start' is set
        if ($range_start === null || (is_array($range_start) && count($range_start) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $range_start when calling getAccessLogsWithoutTotalCount'
            );
        }
        // verify the required parameter 'range_end' is set
        if ($range_end === null || (is_array($range_end) && count($range_end) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $range_end when calling getAccessLogsWithoutTotalCount'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/access_logs/no_total';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($method !== null) {
            $queryParams['method'] = ObjectSerializer::toQueryValue($method);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($range_start !== null) {
            $queryParams['rangeStart'] = ObjectSerializer::toQueryValue($range_start);
        }
        // query params
        if ($range_end !== null) {
            $queryParams['rangeEnd'] = ObjectSerializer::toQueryValue($range_end);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccount
     *
     * Get Account Details
     *
     * @param  int $account_id account_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\Account
     */
    public function getAccount($account_id)
    {
        list($response) = $this->getAccountWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation getAccountWithHttpInfo
     *
     * Get Account Details
     *
     * @param  int $account_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\Account, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountWithHttpInfo($account_id)
    {
        $request = $this->getAccountRequest($account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\Account' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\Account', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\Account';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\Account',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountAsync
     *
     * Get Account Details
     *
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountAsync($account_id)
    {
        return $this->getAccountAsyncWithHttpInfo($account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountAsyncWithHttpInfo
     *
     * Get Account Details
     *
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountAsyncWithHttpInfo($account_id)
    {
        $returnType = '\TalonOne\Client\Model\Account';
        $request = $this->getAccountRequest($account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccount'
     *
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAccountRequest($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getAccount'
            );
        }

        $resourcePath = '/v1/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccountAnalytics
     *
     * Get Account Analytics
     *
     * @param  int $account_id account_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\AccountAnalytics
     */
    public function getAccountAnalytics($account_id)
    {
        list($response) = $this->getAccountAnalyticsWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation getAccountAnalyticsWithHttpInfo
     *
     * Get Account Analytics
     *
     * @param  int $account_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\AccountAnalytics, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountAnalyticsWithHttpInfo($account_id)
    {
        $request = $this->getAccountAnalyticsRequest($account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\AccountAnalytics' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\AccountAnalytics', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\AccountAnalytics';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\AccountAnalytics',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountAnalyticsAsync
     *
     * Get Account Analytics
     *
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountAnalyticsAsync($account_id)
    {
        return $this->getAccountAnalyticsAsyncWithHttpInfo($account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountAnalyticsAsyncWithHttpInfo
     *
     * Get Account Analytics
     *
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountAnalyticsAsyncWithHttpInfo($account_id)
    {
        $returnType = '\TalonOne\Client\Model\AccountAnalytics';
        $request = $this->getAccountAnalyticsRequest($account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccountAnalytics'
     *
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAccountAnalyticsRequest($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getAccountAnalytics'
            );
        }

        $resourcePath = '/v1/accounts/{accountId}/analytics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAdditionalCost
     *
     * Get an additional cost
     *
     * @param  int $additional_cost_id additional_cost_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\AccountAdditionalCost
     */
    public function getAdditionalCost($additional_cost_id)
    {
        list($response) = $this->getAdditionalCostWithHttpInfo($additional_cost_id);
        return $response;
    }

    /**
     * Operation getAdditionalCostWithHttpInfo
     *
     * Get an additional cost
     *
     * @param  int $additional_cost_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\AccountAdditionalCost, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAdditionalCostWithHttpInfo($additional_cost_id)
    {
        $request = $this->getAdditionalCostRequest($additional_cost_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\AccountAdditionalCost' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\AccountAdditionalCost', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\AccountAdditionalCost';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\AccountAdditionalCost',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAdditionalCostAsync
     *
     * Get an additional cost
     *
     * @param  int $additional_cost_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdditionalCostAsync($additional_cost_id)
    {
        return $this->getAdditionalCostAsyncWithHttpInfo($additional_cost_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAdditionalCostAsyncWithHttpInfo
     *
     * Get an additional cost
     *
     * @param  int $additional_cost_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdditionalCostAsyncWithHttpInfo($additional_cost_id)
    {
        $returnType = '\TalonOne\Client\Model\AccountAdditionalCost';
        $request = $this->getAdditionalCostRequest($additional_cost_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAdditionalCost'
     *
     * @param  int $additional_cost_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAdditionalCostRequest($additional_cost_id)
    {
        // verify the required parameter 'additional_cost_id' is set
        if ($additional_cost_id === null || (is_array($additional_cost_id) && count($additional_cost_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $additional_cost_id when calling getAdditionalCost'
            );
        }

        $resourcePath = '/v1/additional_costs/{additionalCostId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($additional_cost_id !== null) {
            $resourcePath = str_replace(
                '{' . 'additionalCostId' . '}',
                ObjectSerializer::toPathValue($additional_cost_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAdditionalCosts
     *
     * List additional costs
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20021
     */
    public function getAdditionalCosts($page_size = null, $skip = null, $sort = null)
    {
        list($response) = $this->getAdditionalCostsWithHttpInfo($page_size, $skip, $sort);
        return $response;
    }

    /**
     * Operation getAdditionalCostsWithHttpInfo
     *
     * List additional costs
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20021, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAdditionalCostsWithHttpInfo($page_size = null, $skip = null, $sort = null)
    {
        $request = $this->getAdditionalCostsRequest($page_size, $skip, $sort);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20021' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20021', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20021';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20021',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAdditionalCostsAsync
     *
     * List additional costs
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdditionalCostsAsync($page_size = null, $skip = null, $sort = null)
    {
        return $this->getAdditionalCostsAsyncWithHttpInfo($page_size, $skip, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAdditionalCostsAsyncWithHttpInfo
     *
     * List additional costs
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdditionalCostsAsyncWithHttpInfo($page_size = null, $skip = null, $sort = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20021';
        $request = $this->getAdditionalCostsRequest($page_size, $skip, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAdditionalCosts'
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAdditionalCostsRequest($page_size = null, $skip = null, $sort = null)
    {

        $resourcePath = '/v1/additional_costs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllAccessLogs
     *
     * Get all access logs
     *
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  string $path Only return results where the request path matches the given regular expression. (optional)
     * @param  string $method Only return results where the request method matches the given regular expression. (optional)
     * @param  string $status Filter results by HTTP status codes. (optional)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse2009
     */
    public function getAllAccessLogs($range_start, $range_end, $path = null, $method = null, $status = null, $page_size = null, $skip = null, $sort = null)
    {
        list($response) = $this->getAllAccessLogsWithHttpInfo($range_start, $range_end, $path, $method, $status, $page_size, $skip, $sort);
        return $response;
    }

    /**
     * Operation getAllAccessLogsWithHttpInfo
     *
     * Get all access logs
     *
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  string $path Only return results where the request path matches the given regular expression. (optional)
     * @param  string $method Only return results where the request method matches the given regular expression. (optional)
     * @param  string $status Filter results by HTTP status codes. (optional)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse2009, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllAccessLogsWithHttpInfo($range_start, $range_end, $path = null, $method = null, $status = null, $page_size = null, $skip = null, $sort = null)
    {
        $request = $this->getAllAccessLogsRequest($range_start, $range_end, $path, $method, $status, $page_size, $skip, $sort);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse2009' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse2009', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse2009';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse2009',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllAccessLogsAsync
     *
     * Get all access logs
     *
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  string $path Only return results where the request path matches the given regular expression. (optional)
     * @param  string $method Only return results where the request method matches the given regular expression. (optional)
     * @param  string $status Filter results by HTTP status codes. (optional)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllAccessLogsAsync($range_start, $range_end, $path = null, $method = null, $status = null, $page_size = null, $skip = null, $sort = null)
    {
        return $this->getAllAccessLogsAsyncWithHttpInfo($range_start, $range_end, $path, $method, $status, $page_size, $skip, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllAccessLogsAsyncWithHttpInfo
     *
     * Get all access logs
     *
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  string $path Only return results where the request path matches the given regular expression. (optional)
     * @param  string $method Only return results where the request method matches the given regular expression. (optional)
     * @param  string $status Filter results by HTTP status codes. (optional)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllAccessLogsAsyncWithHttpInfo($range_start, $range_end, $path = null, $method = null, $status = null, $page_size = null, $skip = null, $sort = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse2009';
        $request = $this->getAllAccessLogsRequest($range_start, $range_end, $path, $method, $status, $page_size, $skip, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllAccessLogs'
     *
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  string $path Only return results where the request path matches the given regular expression. (optional)
     * @param  string $method Only return results where the request method matches the given regular expression. (optional)
     * @param  string $status Filter results by HTTP status codes. (optional)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllAccessLogsRequest($range_start, $range_end, $path = null, $method = null, $status = null, $page_size = null, $skip = null, $sort = null)
    {
        // verify the required parameter 'range_start' is set
        if ($range_start === null || (is_array($range_start) && count($range_start) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $range_start when calling getAllAccessLogs'
            );
        }
        // verify the required parameter 'range_end' is set
        if ($range_end === null || (is_array($range_end) && count($range_end) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $range_end when calling getAllAccessLogs'
            );
        }

        $resourcePath = '/v1/access_logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($range_start !== null) {
            $queryParams['rangeStart'] = ObjectSerializer::toQueryValue($range_start);
        }
        // query params
        if ($range_end !== null) {
            $queryParams['rangeEnd'] = ObjectSerializer::toQueryValue($range_end);
        }
        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($method !== null) {
            $queryParams['method'] = ObjectSerializer::toQueryValue($method);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllRoles
     *
     * Get all roles.
     *
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20030
     */
    public function getAllRoles()
    {
        list($response) = $this->getAllRolesWithHttpInfo();
        return $response;
    }

    /**
     * Operation getAllRolesWithHttpInfo
     *
     * Get all roles.
     *
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20030, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllRolesWithHttpInfo()
    {
        $request = $this->getAllRolesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20030' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20030', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20030';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20030',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllRolesAsync
     *
     * Get all roles.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllRolesAsync()
    {
        return $this->getAllRolesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllRolesAsyncWithHttpInfo
     *
     * Get all roles.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllRolesAsyncWithHttpInfo()
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20030';
        $request = $this->getAllRolesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllRoles'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllRolesRequest()
    {

        $resourcePath = '/v1/roles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApplication
     *
     * Get Application
     *
     * @param  int $application_id application_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\Application
     */
    public function getApplication($application_id)
    {
        list($response) = $this->getApplicationWithHttpInfo($application_id);
        return $response;
    }

    /**
     * Operation getApplicationWithHttpInfo
     *
     * Get Application
     *
     * @param  int $application_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\Application, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApplicationWithHttpInfo($application_id)
    {
        $request = $this->getApplicationRequest($application_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\Application' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\Application', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\Application';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\Application',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApplicationAsync
     *
     * Get Application
     *
     * @param  int $application_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationAsync($application_id)
    {
        return $this->getApplicationAsyncWithHttpInfo($application_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApplicationAsyncWithHttpInfo
     *
     * Get Application
     *
     * @param  int $application_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationAsyncWithHttpInfo($application_id)
    {
        $returnType = '\TalonOne\Client\Model\Application';
        $request = $this->getApplicationRequest($application_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApplication'
     *
     * @param  int $application_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApplicationRequest($application_id)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getApplication'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApplicationApiHealth
     *
     * Get report of health of application API
     *
     * @param  int $application_id application_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\ApplicationApiHealth
     */
    public function getApplicationApiHealth($application_id)
    {
        list($response) = $this->getApplicationApiHealthWithHttpInfo($application_id);
        return $response;
    }

    /**
     * Operation getApplicationApiHealthWithHttpInfo
     *
     * Get report of health of application API
     *
     * @param  int $application_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\ApplicationApiHealth, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApplicationApiHealthWithHttpInfo($application_id)
    {
        $request = $this->getApplicationApiHealthRequest($application_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\ApplicationApiHealth' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\ApplicationApiHealth', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\ApplicationApiHealth';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\ApplicationApiHealth',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApplicationApiHealthAsync
     *
     * Get report of health of application API
     *
     * @param  int $application_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationApiHealthAsync($application_id)
    {
        return $this->getApplicationApiHealthAsyncWithHttpInfo($application_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApplicationApiHealthAsyncWithHttpInfo
     *
     * Get report of health of application API
     *
     * @param  int $application_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationApiHealthAsyncWithHttpInfo($application_id)
    {
        $returnType = '\TalonOne\Client\Model\ApplicationApiHealth';
        $request = $this->getApplicationApiHealthRequest($application_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApplicationApiHealth'
     *
     * @param  int $application_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApplicationApiHealthRequest($application_id)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getApplicationApiHealth'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/health_report';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApplicationCustomer
     *
     * Get Application Customer
     *
     * @param  int $application_id application_id (required)
     * @param  int $customer_id customer_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\ApplicationCustomer
     */
    public function getApplicationCustomer($application_id, $customer_id)
    {
        list($response) = $this->getApplicationCustomerWithHttpInfo($application_id, $customer_id);
        return $response;
    }

    /**
     * Operation getApplicationCustomerWithHttpInfo
     *
     * Get Application Customer
     *
     * @param  int $application_id (required)
     * @param  int $customer_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\ApplicationCustomer, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApplicationCustomerWithHttpInfo($application_id, $customer_id)
    {
        $request = $this->getApplicationCustomerRequest($application_id, $customer_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\ApplicationCustomer' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\ApplicationCustomer', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\ApplicationCustomer';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\ApplicationCustomer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApplicationCustomerAsync
     *
     * Get Application Customer
     *
     * @param  int $application_id (required)
     * @param  int $customer_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationCustomerAsync($application_id, $customer_id)
    {
        return $this->getApplicationCustomerAsyncWithHttpInfo($application_id, $customer_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApplicationCustomerAsyncWithHttpInfo
     *
     * Get Application Customer
     *
     * @param  int $application_id (required)
     * @param  int $customer_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationCustomerAsyncWithHttpInfo($application_id, $customer_id)
    {
        $returnType = '\TalonOne\Client\Model\ApplicationCustomer';
        $request = $this->getApplicationCustomerRequest($application_id, $customer_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApplicationCustomer'
     *
     * @param  int $application_id (required)
     * @param  int $customer_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApplicationCustomerRequest($application_id, $customer_id)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getApplicationCustomer'
            );
        }
        // verify the required parameter 'customer_id' is set
        if ($customer_id === null || (is_array($customer_id) && count($customer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customer_id when calling getApplicationCustomer'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/customers/{customerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($customer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'customerId' . '}',
                ObjectSerializer::toPathValue($customer_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApplicationCustomers
     *
     * List Application Customers
     *
     * @param  int $application_id application_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20012
     */
    public function getApplicationCustomers($application_id)
    {
        list($response) = $this->getApplicationCustomersWithHttpInfo($application_id);
        return $response;
    }

    /**
     * Operation getApplicationCustomersWithHttpInfo
     *
     * List Application Customers
     *
     * @param  int $application_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20012, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApplicationCustomersWithHttpInfo($application_id)
    {
        $request = $this->getApplicationCustomersRequest($application_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20012' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20012', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20012';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20012',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApplicationCustomersAsync
     *
     * List Application Customers
     *
     * @param  int $application_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationCustomersAsync($application_id)
    {
        return $this->getApplicationCustomersAsyncWithHttpInfo($application_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApplicationCustomersAsyncWithHttpInfo
     *
     * List Application Customers
     *
     * @param  int $application_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationCustomersAsyncWithHttpInfo($application_id)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20012';
        $request = $this->getApplicationCustomersRequest($application_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApplicationCustomers'
     *
     * @param  int $application_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApplicationCustomersRequest($application_id)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getApplicationCustomers'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/customers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApplicationCustomersByAttributes
     *
     * Get a list of the customer profiles that match the given attributes
     *
     * @param  \TalonOne\Client\Model\ApplicationCustomerSearch $body body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20013
     */
    public function getApplicationCustomersByAttributes($body)
    {
        list($response) = $this->getApplicationCustomersByAttributesWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation getApplicationCustomersByAttributesWithHttpInfo
     *
     * Get a list of the customer profiles that match the given attributes
     *
     * @param  \TalonOne\Client\Model\ApplicationCustomerSearch $body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20013, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApplicationCustomersByAttributesWithHttpInfo($body)
    {
        $request = $this->getApplicationCustomersByAttributesRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20013' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20013', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20013';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20013',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApplicationCustomersByAttributesAsync
     *
     * Get a list of the customer profiles that match the given attributes
     *
     * @param  \TalonOne\Client\Model\ApplicationCustomerSearch $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationCustomersByAttributesAsync($body)
    {
        return $this->getApplicationCustomersByAttributesAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApplicationCustomersByAttributesAsyncWithHttpInfo
     *
     * Get a list of the customer profiles that match the given attributes
     *
     * @param  \TalonOne\Client\Model\ApplicationCustomerSearch $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationCustomersByAttributesAsyncWithHttpInfo($body)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20013';
        $request = $this->getApplicationCustomersByAttributesRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApplicationCustomersByAttributes'
     *
     * @param  \TalonOne\Client\Model\ApplicationCustomerSearch $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApplicationCustomersByAttributesRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling getApplicationCustomersByAttributes'
            );
        }

        $resourcePath = '/v1/application_customer_search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Content-Signature');
        if ($apiKey !== null) {
            $headers['Content-Signature'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApplicationEventTypes
     *
     * List Applications Event Types
     *
     * @param  int $application_id application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20019
     */
    public function getApplicationEventTypes($application_id, $page_size = null, $skip = null, $sort = null)
    {
        list($response) = $this->getApplicationEventTypesWithHttpInfo($application_id, $page_size, $skip, $sort);
        return $response;
    }

    /**
     * Operation getApplicationEventTypesWithHttpInfo
     *
     * List Applications Event Types
     *
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20019, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApplicationEventTypesWithHttpInfo($application_id, $page_size = null, $skip = null, $sort = null)
    {
        $request = $this->getApplicationEventTypesRequest($application_id, $page_size, $skip, $sort);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20019' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20019', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20019';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20019',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApplicationEventTypesAsync
     *
     * List Applications Event Types
     *
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationEventTypesAsync($application_id, $page_size = null, $skip = null, $sort = null)
    {
        return $this->getApplicationEventTypesAsyncWithHttpInfo($application_id, $page_size, $skip, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApplicationEventTypesAsyncWithHttpInfo
     *
     * List Applications Event Types
     *
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationEventTypesAsyncWithHttpInfo($application_id, $page_size = null, $skip = null, $sort = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20019';
        $request = $this->getApplicationEventTypesRequest($application_id, $page_size, $skip, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApplicationEventTypes'
     *
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApplicationEventTypesRequest($application_id, $page_size = null, $skip = null, $sort = null)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getApplicationEventTypes'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/event_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApplicationEvents
     *
     * List Applications Events
     *
     * @param  int $application_id application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $type Comma-separated list of types by which to filter events. Must be exact match(es). (optional)
     * @param  \DateTime $created_before Only return events created before this date (optional)
     * @param  \DateTime $created_after Only return events created after this date (optional)
     * @param  string $session Session integration ID filter for events. Must be exact match. (optional)
     * @param  string $profile Profile integration ID filter for events. Must be exact match. (optional)
     * @param  string $customer_name Customer name filter for events. Will match substrings case-insensitively. (optional)
     * @param  string $customer_email Customer e-mail address filter for events. Will match substrings case-insensitively. (optional)
     * @param  string $coupon_code Coupon code (optional)
     * @param  string $referral_code Referral code (optional)
     * @param  string $rule_query Rule name filter for events (optional)
     * @param  string $campaign_query Campaign name filter for events (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20017
     */
    public function getApplicationEvents($application_id, $page_size = null, $skip = null, $sort = null, $type = null, $created_before = null, $created_after = null, $session = null, $profile = null, $customer_name = null, $customer_email = null, $coupon_code = null, $referral_code = null, $rule_query = null, $campaign_query = null)
    {
        list($response) = $this->getApplicationEventsWithHttpInfo($application_id, $page_size, $skip, $sort, $type, $created_before, $created_after, $session, $profile, $customer_name, $customer_email, $coupon_code, $referral_code, $rule_query, $campaign_query);
        return $response;
    }

    /**
     * Operation getApplicationEventsWithHttpInfo
     *
     * List Applications Events
     *
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $type Comma-separated list of types by which to filter events. Must be exact match(es). (optional)
     * @param  \DateTime $created_before Only return events created before this date (optional)
     * @param  \DateTime $created_after Only return events created after this date (optional)
     * @param  string $session Session integration ID filter for events. Must be exact match. (optional)
     * @param  string $profile Profile integration ID filter for events. Must be exact match. (optional)
     * @param  string $customer_name Customer name filter for events. Will match substrings case-insensitively. (optional)
     * @param  string $customer_email Customer e-mail address filter for events. Will match substrings case-insensitively. (optional)
     * @param  string $coupon_code Coupon code (optional)
     * @param  string $referral_code Referral code (optional)
     * @param  string $rule_query Rule name filter for events (optional)
     * @param  string $campaign_query Campaign name filter for events (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20017, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApplicationEventsWithHttpInfo($application_id, $page_size = null, $skip = null, $sort = null, $type = null, $created_before = null, $created_after = null, $session = null, $profile = null, $customer_name = null, $customer_email = null, $coupon_code = null, $referral_code = null, $rule_query = null, $campaign_query = null)
    {
        $request = $this->getApplicationEventsRequest($application_id, $page_size, $skip, $sort, $type, $created_before, $created_after, $session, $profile, $customer_name, $customer_email, $coupon_code, $referral_code, $rule_query, $campaign_query);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20017' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20017', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20017';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20017',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApplicationEventsAsync
     *
     * List Applications Events
     *
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $type Comma-separated list of types by which to filter events. Must be exact match(es). (optional)
     * @param  \DateTime $created_before Only return events created before this date (optional)
     * @param  \DateTime $created_after Only return events created after this date (optional)
     * @param  string $session Session integration ID filter for events. Must be exact match. (optional)
     * @param  string $profile Profile integration ID filter for events. Must be exact match. (optional)
     * @param  string $customer_name Customer name filter for events. Will match substrings case-insensitively. (optional)
     * @param  string $customer_email Customer e-mail address filter for events. Will match substrings case-insensitively. (optional)
     * @param  string $coupon_code Coupon code (optional)
     * @param  string $referral_code Referral code (optional)
     * @param  string $rule_query Rule name filter for events (optional)
     * @param  string $campaign_query Campaign name filter for events (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationEventsAsync($application_id, $page_size = null, $skip = null, $sort = null, $type = null, $created_before = null, $created_after = null, $session = null, $profile = null, $customer_name = null, $customer_email = null, $coupon_code = null, $referral_code = null, $rule_query = null, $campaign_query = null)
    {
        return $this->getApplicationEventsAsyncWithHttpInfo($application_id, $page_size, $skip, $sort, $type, $created_before, $created_after, $session, $profile, $customer_name, $customer_email, $coupon_code, $referral_code, $rule_query, $campaign_query)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApplicationEventsAsyncWithHttpInfo
     *
     * List Applications Events
     *
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $type Comma-separated list of types by which to filter events. Must be exact match(es). (optional)
     * @param  \DateTime $created_before Only return events created before this date (optional)
     * @param  \DateTime $created_after Only return events created after this date (optional)
     * @param  string $session Session integration ID filter for events. Must be exact match. (optional)
     * @param  string $profile Profile integration ID filter for events. Must be exact match. (optional)
     * @param  string $customer_name Customer name filter for events. Will match substrings case-insensitively. (optional)
     * @param  string $customer_email Customer e-mail address filter for events. Will match substrings case-insensitively. (optional)
     * @param  string $coupon_code Coupon code (optional)
     * @param  string $referral_code Referral code (optional)
     * @param  string $rule_query Rule name filter for events (optional)
     * @param  string $campaign_query Campaign name filter for events (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationEventsAsyncWithHttpInfo($application_id, $page_size = null, $skip = null, $sort = null, $type = null, $created_before = null, $created_after = null, $session = null, $profile = null, $customer_name = null, $customer_email = null, $coupon_code = null, $referral_code = null, $rule_query = null, $campaign_query = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20017';
        $request = $this->getApplicationEventsRequest($application_id, $page_size, $skip, $sort, $type, $created_before, $created_after, $session, $profile, $customer_name, $customer_email, $coupon_code, $referral_code, $rule_query, $campaign_query);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApplicationEvents'
     *
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $type Comma-separated list of types by which to filter events. Must be exact match(es). (optional)
     * @param  \DateTime $created_before Only return events created before this date (optional)
     * @param  \DateTime $created_after Only return events created after this date (optional)
     * @param  string $session Session integration ID filter for events. Must be exact match. (optional)
     * @param  string $profile Profile integration ID filter for events. Must be exact match. (optional)
     * @param  string $customer_name Customer name filter for events. Will match substrings case-insensitively. (optional)
     * @param  string $customer_email Customer e-mail address filter for events. Will match substrings case-insensitively. (optional)
     * @param  string $coupon_code Coupon code (optional)
     * @param  string $referral_code Referral code (optional)
     * @param  string $rule_query Rule name filter for events (optional)
     * @param  string $campaign_query Campaign name filter for events (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApplicationEventsRequest($application_id, $page_size = null, $skip = null, $sort = null, $type = null, $created_before = null, $created_after = null, $session = null, $profile = null, $customer_name = null, $customer_email = null, $coupon_code = null, $referral_code = null, $rule_query = null, $campaign_query = null)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getApplicationEvents'
            );
        }
        if ($customer_name !== null && strlen($customer_name) < 2) {
            throw new \InvalidArgumentException('invalid length for "$customer_name" when calling ManagementApi.getApplicationEvents, must be bigger than or equal to 2.');
        }

        if ($customer_email !== null && strlen($customer_email) < 2) {
            throw new \InvalidArgumentException('invalid length for "$customer_email" when calling ManagementApi.getApplicationEvents, must be bigger than or equal to 2.');
        }


        $resourcePath = '/v1/applications/{applicationId}/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($created_before !== null) {
            $queryParams['createdBefore'] = ObjectSerializer::toQueryValue($created_before);
        }
        // query params
        if ($created_after !== null) {
            $queryParams['createdAfter'] = ObjectSerializer::toQueryValue($created_after);
        }
        // query params
        if ($session !== null) {
            $queryParams['session'] = ObjectSerializer::toQueryValue($session);
        }
        // query params
        if ($profile !== null) {
            $queryParams['profile'] = ObjectSerializer::toQueryValue($profile);
        }
        // query params
        if ($customer_name !== null) {
            $queryParams['customerName'] = ObjectSerializer::toQueryValue($customer_name);
        }
        // query params
        if ($customer_email !== null) {
            $queryParams['customerEmail'] = ObjectSerializer::toQueryValue($customer_email);
        }
        // query params
        if ($coupon_code !== null) {
            $queryParams['couponCode'] = ObjectSerializer::toQueryValue($coupon_code);
        }
        // query params
        if ($referral_code !== null) {
            $queryParams['referralCode'] = ObjectSerializer::toQueryValue($referral_code);
        }
        // query params
        if ($rule_query !== null) {
            $queryParams['ruleQuery'] = ObjectSerializer::toQueryValue($rule_query);
        }
        // query params
        if ($campaign_query !== null) {
            $queryParams['campaignQuery'] = ObjectSerializer::toQueryValue($campaign_query);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApplicationEventsWithoutTotalCount
     *
     * List Applications Events
     *
     * @param  int $application_id application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $type Comma-separated list of types by which to filter events. Must be exact match(es). (optional)
     * @param  \DateTime $created_before Only return events created before this date (optional)
     * @param  \DateTime $created_after Only return events created after this date (optional)
     * @param  string $session Session integration ID filter for events. Must be exact match. (optional)
     * @param  string $profile Profile integration ID filter for events. Must be exact match. (optional)
     * @param  string $customer_name Customer name filter for events. Will match substrings case-insensitively. (optional)
     * @param  string $customer_email Customer e-mail address filter for events. Will match substrings case-insensitively. (optional)
     * @param  string $coupon_code Coupon code (optional)
     * @param  string $referral_code Referral code (optional)
     * @param  string $rule_query Rule name filter for events (optional)
     * @param  string $campaign_query Campaign name filter for events (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20018
     */
    public function getApplicationEventsWithoutTotalCount($application_id, $page_size = null, $skip = null, $sort = null, $type = null, $created_before = null, $created_after = null, $session = null, $profile = null, $customer_name = null, $customer_email = null, $coupon_code = null, $referral_code = null, $rule_query = null, $campaign_query = null)
    {
        list($response) = $this->getApplicationEventsWithoutTotalCountWithHttpInfo($application_id, $page_size, $skip, $sort, $type, $created_before, $created_after, $session, $profile, $customer_name, $customer_email, $coupon_code, $referral_code, $rule_query, $campaign_query);
        return $response;
    }

    /**
     * Operation getApplicationEventsWithoutTotalCountWithHttpInfo
     *
     * List Applications Events
     *
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $type Comma-separated list of types by which to filter events. Must be exact match(es). (optional)
     * @param  \DateTime $created_before Only return events created before this date (optional)
     * @param  \DateTime $created_after Only return events created after this date (optional)
     * @param  string $session Session integration ID filter for events. Must be exact match. (optional)
     * @param  string $profile Profile integration ID filter for events. Must be exact match. (optional)
     * @param  string $customer_name Customer name filter for events. Will match substrings case-insensitively. (optional)
     * @param  string $customer_email Customer e-mail address filter for events. Will match substrings case-insensitively. (optional)
     * @param  string $coupon_code Coupon code (optional)
     * @param  string $referral_code Referral code (optional)
     * @param  string $rule_query Rule name filter for events (optional)
     * @param  string $campaign_query Campaign name filter for events (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20018, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApplicationEventsWithoutTotalCountWithHttpInfo($application_id, $page_size = null, $skip = null, $sort = null, $type = null, $created_before = null, $created_after = null, $session = null, $profile = null, $customer_name = null, $customer_email = null, $coupon_code = null, $referral_code = null, $rule_query = null, $campaign_query = null)
    {
        $request = $this->getApplicationEventsWithoutTotalCountRequest($application_id, $page_size, $skip, $sort, $type, $created_before, $created_after, $session, $profile, $customer_name, $customer_email, $coupon_code, $referral_code, $rule_query, $campaign_query);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20018' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20018', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20018';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20018',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApplicationEventsWithoutTotalCountAsync
     *
     * List Applications Events
     *
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $type Comma-separated list of types by which to filter events. Must be exact match(es). (optional)
     * @param  \DateTime $created_before Only return events created before this date (optional)
     * @param  \DateTime $created_after Only return events created after this date (optional)
     * @param  string $session Session integration ID filter for events. Must be exact match. (optional)
     * @param  string $profile Profile integration ID filter for events. Must be exact match. (optional)
     * @param  string $customer_name Customer name filter for events. Will match substrings case-insensitively. (optional)
     * @param  string $customer_email Customer e-mail address filter for events. Will match substrings case-insensitively. (optional)
     * @param  string $coupon_code Coupon code (optional)
     * @param  string $referral_code Referral code (optional)
     * @param  string $rule_query Rule name filter for events (optional)
     * @param  string $campaign_query Campaign name filter for events (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationEventsWithoutTotalCountAsync($application_id, $page_size = null, $skip = null, $sort = null, $type = null, $created_before = null, $created_after = null, $session = null, $profile = null, $customer_name = null, $customer_email = null, $coupon_code = null, $referral_code = null, $rule_query = null, $campaign_query = null)
    {
        return $this->getApplicationEventsWithoutTotalCountAsyncWithHttpInfo($application_id, $page_size, $skip, $sort, $type, $created_before, $created_after, $session, $profile, $customer_name, $customer_email, $coupon_code, $referral_code, $rule_query, $campaign_query)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApplicationEventsWithoutTotalCountAsyncWithHttpInfo
     *
     * List Applications Events
     *
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $type Comma-separated list of types by which to filter events. Must be exact match(es). (optional)
     * @param  \DateTime $created_before Only return events created before this date (optional)
     * @param  \DateTime $created_after Only return events created after this date (optional)
     * @param  string $session Session integration ID filter for events. Must be exact match. (optional)
     * @param  string $profile Profile integration ID filter for events. Must be exact match. (optional)
     * @param  string $customer_name Customer name filter for events. Will match substrings case-insensitively. (optional)
     * @param  string $customer_email Customer e-mail address filter for events. Will match substrings case-insensitively. (optional)
     * @param  string $coupon_code Coupon code (optional)
     * @param  string $referral_code Referral code (optional)
     * @param  string $rule_query Rule name filter for events (optional)
     * @param  string $campaign_query Campaign name filter for events (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationEventsWithoutTotalCountAsyncWithHttpInfo($application_id, $page_size = null, $skip = null, $sort = null, $type = null, $created_before = null, $created_after = null, $session = null, $profile = null, $customer_name = null, $customer_email = null, $coupon_code = null, $referral_code = null, $rule_query = null, $campaign_query = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20018';
        $request = $this->getApplicationEventsWithoutTotalCountRequest($application_id, $page_size, $skip, $sort, $type, $created_before, $created_after, $session, $profile, $customer_name, $customer_email, $coupon_code, $referral_code, $rule_query, $campaign_query);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApplicationEventsWithoutTotalCount'
     *
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $type Comma-separated list of types by which to filter events. Must be exact match(es). (optional)
     * @param  \DateTime $created_before Only return events created before this date (optional)
     * @param  \DateTime $created_after Only return events created after this date (optional)
     * @param  string $session Session integration ID filter for events. Must be exact match. (optional)
     * @param  string $profile Profile integration ID filter for events. Must be exact match. (optional)
     * @param  string $customer_name Customer name filter for events. Will match substrings case-insensitively. (optional)
     * @param  string $customer_email Customer e-mail address filter for events. Will match substrings case-insensitively. (optional)
     * @param  string $coupon_code Coupon code (optional)
     * @param  string $referral_code Referral code (optional)
     * @param  string $rule_query Rule name filter for events (optional)
     * @param  string $campaign_query Campaign name filter for events (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApplicationEventsWithoutTotalCountRequest($application_id, $page_size = null, $skip = null, $sort = null, $type = null, $created_before = null, $created_after = null, $session = null, $profile = null, $customer_name = null, $customer_email = null, $coupon_code = null, $referral_code = null, $rule_query = null, $campaign_query = null)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getApplicationEventsWithoutTotalCount'
            );
        }
        if ($customer_name !== null && strlen($customer_name) < 2) {
            throw new \InvalidArgumentException('invalid length for "$customer_name" when calling ManagementApi.getApplicationEventsWithoutTotalCount, must be bigger than or equal to 2.');
        }

        if ($customer_email !== null && strlen($customer_email) < 2) {
            throw new \InvalidArgumentException('invalid length for "$customer_email" when calling ManagementApi.getApplicationEventsWithoutTotalCount, must be bigger than or equal to 2.');
        }


        $resourcePath = '/v1/applications/{applicationId}/events/no_total';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($created_before !== null) {
            $queryParams['createdBefore'] = ObjectSerializer::toQueryValue($created_before);
        }
        // query params
        if ($created_after !== null) {
            $queryParams['createdAfter'] = ObjectSerializer::toQueryValue($created_after);
        }
        // query params
        if ($session !== null) {
            $queryParams['session'] = ObjectSerializer::toQueryValue($session);
        }
        // query params
        if ($profile !== null) {
            $queryParams['profile'] = ObjectSerializer::toQueryValue($profile);
        }
        // query params
        if ($customer_name !== null) {
            $queryParams['customerName'] = ObjectSerializer::toQueryValue($customer_name);
        }
        // query params
        if ($customer_email !== null) {
            $queryParams['customerEmail'] = ObjectSerializer::toQueryValue($customer_email);
        }
        // query params
        if ($coupon_code !== null) {
            $queryParams['couponCode'] = ObjectSerializer::toQueryValue($coupon_code);
        }
        // query params
        if ($referral_code !== null) {
            $queryParams['referralCode'] = ObjectSerializer::toQueryValue($referral_code);
        }
        // query params
        if ($rule_query !== null) {
            $queryParams['ruleQuery'] = ObjectSerializer::toQueryValue($rule_query);
        }
        // query params
        if ($campaign_query !== null) {
            $queryParams['campaignQuery'] = ObjectSerializer::toQueryValue($campaign_query);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApplicationSession
     *
     * Get Application Session
     *
     * @param  int $application_id application_id (required)
     * @param  int $session_id session_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\ApplicationSession
     */
    public function getApplicationSession($application_id, $session_id)
    {
        list($response) = $this->getApplicationSessionWithHttpInfo($application_id, $session_id);
        return $response;
    }

    /**
     * Operation getApplicationSessionWithHttpInfo
     *
     * Get Application Session
     *
     * @param  int $application_id (required)
     * @param  int $session_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\ApplicationSession, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApplicationSessionWithHttpInfo($application_id, $session_id)
    {
        $request = $this->getApplicationSessionRequest($application_id, $session_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\ApplicationSession' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\ApplicationSession', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\ApplicationSession';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\ApplicationSession',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApplicationSessionAsync
     *
     * Get Application Session
     *
     * @param  int $application_id (required)
     * @param  int $session_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationSessionAsync($application_id, $session_id)
    {
        return $this->getApplicationSessionAsyncWithHttpInfo($application_id, $session_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApplicationSessionAsyncWithHttpInfo
     *
     * Get Application Session
     *
     * @param  int $application_id (required)
     * @param  int $session_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationSessionAsyncWithHttpInfo($application_id, $session_id)
    {
        $returnType = '\TalonOne\Client\Model\ApplicationSession';
        $request = $this->getApplicationSessionRequest($application_id, $session_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApplicationSession'
     *
     * @param  int $application_id (required)
     * @param  int $session_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApplicationSessionRequest($application_id, $session_id)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getApplicationSession'
            );
        }
        // verify the required parameter 'session_id' is set
        if ($session_id === null || (is_array($session_id) && count($session_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session_id when calling getApplicationSession'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/sessions/{sessionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($session_id !== null) {
            $resourcePath = str_replace(
                '{' . 'sessionId' . '}',
                ObjectSerializer::toPathValue($session_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApplicationSessions
     *
     * List Application Sessions
     *
     * @param  int $application_id application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $profile Profile integration ID filter for sessions. Must be exact match. (optional)
     * @param  string $state Filter by sessions with this state. Must be exact match. (optional)
     * @param  string $coupon Filter by sessions with this coupon. Must be exact match. (optional)
     * @param  string $referral Filter by sessions with this referral. Must be exact match. (optional)
     * @param  string $integration_id Filter by sessions with this integrationId. Must be exact match. (optional)
     * @param  string $customer_id Filter by integration ID of the customer for the session (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20016
     */
    public function getApplicationSessions($application_id, $page_size = null, $skip = null, $sort = null, $profile = null, $state = null, $coupon = null, $referral = null, $integration_id = null, $customer_id = null)
    {
        list($response) = $this->getApplicationSessionsWithHttpInfo($application_id, $page_size, $skip, $sort, $profile, $state, $coupon, $referral, $integration_id, $customer_id);
        return $response;
    }

    /**
     * Operation getApplicationSessionsWithHttpInfo
     *
     * List Application Sessions
     *
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $profile Profile integration ID filter for sessions. Must be exact match. (optional)
     * @param  string $state Filter by sessions with this state. Must be exact match. (optional)
     * @param  string $coupon Filter by sessions with this coupon. Must be exact match. (optional)
     * @param  string $referral Filter by sessions with this referral. Must be exact match. (optional)
     * @param  string $integration_id Filter by sessions with this integrationId. Must be exact match. (optional)
     * @param  string $customer_id Filter by integration ID of the customer for the session (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20016, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApplicationSessionsWithHttpInfo($application_id, $page_size = null, $skip = null, $sort = null, $profile = null, $state = null, $coupon = null, $referral = null, $integration_id = null, $customer_id = null)
    {
        $request = $this->getApplicationSessionsRequest($application_id, $page_size, $skip, $sort, $profile, $state, $coupon, $referral, $integration_id, $customer_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20016' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20016', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20016';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20016',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApplicationSessionsAsync
     *
     * List Application Sessions
     *
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $profile Profile integration ID filter for sessions. Must be exact match. (optional)
     * @param  string $state Filter by sessions with this state. Must be exact match. (optional)
     * @param  string $coupon Filter by sessions with this coupon. Must be exact match. (optional)
     * @param  string $referral Filter by sessions with this referral. Must be exact match. (optional)
     * @param  string $integration_id Filter by sessions with this integrationId. Must be exact match. (optional)
     * @param  string $customer_id Filter by integration ID of the customer for the session (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationSessionsAsync($application_id, $page_size = null, $skip = null, $sort = null, $profile = null, $state = null, $coupon = null, $referral = null, $integration_id = null, $customer_id = null)
    {
        return $this->getApplicationSessionsAsyncWithHttpInfo($application_id, $page_size, $skip, $sort, $profile, $state, $coupon, $referral, $integration_id, $customer_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApplicationSessionsAsyncWithHttpInfo
     *
     * List Application Sessions
     *
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $profile Profile integration ID filter for sessions. Must be exact match. (optional)
     * @param  string $state Filter by sessions with this state. Must be exact match. (optional)
     * @param  string $coupon Filter by sessions with this coupon. Must be exact match. (optional)
     * @param  string $referral Filter by sessions with this referral. Must be exact match. (optional)
     * @param  string $integration_id Filter by sessions with this integrationId. Must be exact match. (optional)
     * @param  string $customer_id Filter by integration ID of the customer for the session (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationSessionsAsyncWithHttpInfo($application_id, $page_size = null, $skip = null, $sort = null, $profile = null, $state = null, $coupon = null, $referral = null, $integration_id = null, $customer_id = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20016';
        $request = $this->getApplicationSessionsRequest($application_id, $page_size, $skip, $sort, $profile, $state, $coupon, $referral, $integration_id, $customer_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApplicationSessions'
     *
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $profile Profile integration ID filter for sessions. Must be exact match. (optional)
     * @param  string $state Filter by sessions with this state. Must be exact match. (optional)
     * @param  string $coupon Filter by sessions with this coupon. Must be exact match. (optional)
     * @param  string $referral Filter by sessions with this referral. Must be exact match. (optional)
     * @param  string $integration_id Filter by sessions with this integrationId. Must be exact match. (optional)
     * @param  string $customer_id Filter by integration ID of the customer for the session (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApplicationSessionsRequest($application_id, $page_size = null, $skip = null, $sort = null, $profile = null, $state = null, $coupon = null, $referral = null, $integration_id = null, $customer_id = null)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getApplicationSessions'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/sessions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($profile !== null) {
            $queryParams['profile'] = ObjectSerializer::toQueryValue($profile);
        }
        // query params
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state);
        }
        // query params
        if ($coupon !== null) {
            $queryParams['coupon'] = ObjectSerializer::toQueryValue($coupon);
        }
        // query params
        if ($referral !== null) {
            $queryParams['referral'] = ObjectSerializer::toQueryValue($referral);
        }
        // query params
        if ($integration_id !== null) {
            $queryParams['integrationId'] = ObjectSerializer::toQueryValue($integration_id);
        }
        // query params
        if ($customer_id !== null) {
            $queryParams['customerId'] = ObjectSerializer::toQueryValue($customer_id);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApplications
     *
     * List Applications
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse2002
     */
    public function getApplications($page_size = null, $skip = null, $sort = null)
    {
        list($response) = $this->getApplicationsWithHttpInfo($page_size, $skip, $sort);
        return $response;
    }

    /**
     * Operation getApplicationsWithHttpInfo
     *
     * List Applications
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse2002, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApplicationsWithHttpInfo($page_size = null, $skip = null, $sort = null)
    {
        $request = $this->getApplicationsRequest($page_size, $skip, $sort);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse2002' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse2002', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse2002';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse2002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApplicationsAsync
     *
     * List Applications
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationsAsync($page_size = null, $skip = null, $sort = null)
    {
        return $this->getApplicationsAsyncWithHttpInfo($page_size, $skip, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApplicationsAsyncWithHttpInfo
     *
     * List Applications
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationsAsyncWithHttpInfo($page_size = null, $skip = null, $sort = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse2002';
        $request = $this->getApplicationsRequest($page_size, $skip, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApplications'
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApplicationsRequest($page_size = null, $skip = null, $sort = null)
    {

        $resourcePath = '/v1/applications';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAttribute
     *
     * Get a custom attribute
     *
     * @param  int $attribute_id attribute_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\Attribute
     */
    public function getAttribute($attribute_id)
    {
        list($response) = $this->getAttributeWithHttpInfo($attribute_id);
        return $response;
    }

    /**
     * Operation getAttributeWithHttpInfo
     *
     * Get a custom attribute
     *
     * @param  int $attribute_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\Attribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAttributeWithHttpInfo($attribute_id)
    {
        $request = $this->getAttributeRequest($attribute_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\Attribute' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\Attribute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\Attribute';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\Attribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAttributeAsync
     *
     * Get a custom attribute
     *
     * @param  int $attribute_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAttributeAsync($attribute_id)
    {
        return $this->getAttributeAsyncWithHttpInfo($attribute_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAttributeAsyncWithHttpInfo
     *
     * Get a custom attribute
     *
     * @param  int $attribute_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAttributeAsyncWithHttpInfo($attribute_id)
    {
        $returnType = '\TalonOne\Client\Model\Attribute';
        $request = $this->getAttributeRequest($attribute_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAttribute'
     *
     * @param  int $attribute_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAttributeRequest($attribute_id)
    {
        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling getAttribute'
            );
        }

        $resourcePath = '/v1/attributes/{attributeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAttributes
     *
     * List custom attributes
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20020
     */
    public function getAttributes($page_size = null, $skip = null, $sort = null)
    {
        list($response) = $this->getAttributesWithHttpInfo($page_size, $skip, $sort);
        return $response;
    }

    /**
     * Operation getAttributesWithHttpInfo
     *
     * List custom attributes
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20020, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAttributesWithHttpInfo($page_size = null, $skip = null, $sort = null)
    {
        $request = $this->getAttributesRequest($page_size, $skip, $sort);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20020' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20020', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20020';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20020',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAttributesAsync
     *
     * List custom attributes
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAttributesAsync($page_size = null, $skip = null, $sort = null)
    {
        return $this->getAttributesAsyncWithHttpInfo($page_size, $skip, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAttributesAsyncWithHttpInfo
     *
     * List custom attributes
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAttributesAsyncWithHttpInfo($page_size = null, $skip = null, $sort = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20020';
        $request = $this->getAttributesRequest($page_size, $skip, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAttributes'
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAttributesRequest($page_size = null, $skip = null, $sort = null)
    {

        $resourcePath = '/v1/attributes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCampaign
     *
     * Get a Campaign
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\Campaign
     */
    public function getCampaign($application_id, $campaign_id)
    {
        list($response) = $this->getCampaignWithHttpInfo($application_id, $campaign_id);
        return $response;
    }

    /**
     * Operation getCampaignWithHttpInfo
     *
     * Get a Campaign
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\Campaign, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCampaignWithHttpInfo($application_id, $campaign_id)
    {
        $request = $this->getCampaignRequest($application_id, $campaign_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\Campaign' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\Campaign', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\Campaign';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\Campaign',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCampaignAsync
     *
     * Get a Campaign
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCampaignAsync($application_id, $campaign_id)
    {
        return $this->getCampaignAsyncWithHttpInfo($application_id, $campaign_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCampaignAsyncWithHttpInfo
     *
     * Get a Campaign
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCampaignAsyncWithHttpInfo($application_id, $campaign_id)
    {
        $returnType = '\TalonOne\Client\Model\Campaign';
        $request = $this->getCampaignRequest($application_id, $campaign_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCampaign'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCampaignRequest($application_id, $campaign_id)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getCampaign'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling getCampaign'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCampaignAnalytics
     *
     * Get analytics of campaigns
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  string $granularity The time interval between the results in the returned time-series. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20011
     */
    public function getCampaignAnalytics($application_id, $campaign_id, $range_start, $range_end, $granularity = null)
    {
        list($response) = $this->getCampaignAnalyticsWithHttpInfo($application_id, $campaign_id, $range_start, $range_end, $granularity);
        return $response;
    }

    /**
     * Operation getCampaignAnalyticsWithHttpInfo
     *
     * Get analytics of campaigns
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  string $granularity The time interval between the results in the returned time-series. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20011, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCampaignAnalyticsWithHttpInfo($application_id, $campaign_id, $range_start, $range_end, $granularity = null)
    {
        $request = $this->getCampaignAnalyticsRequest($application_id, $campaign_id, $range_start, $range_end, $granularity);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20011' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20011', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20011';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20011',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCampaignAnalyticsAsync
     *
     * Get analytics of campaigns
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  string $granularity The time interval between the results in the returned time-series. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCampaignAnalyticsAsync($application_id, $campaign_id, $range_start, $range_end, $granularity = null)
    {
        return $this->getCampaignAnalyticsAsyncWithHttpInfo($application_id, $campaign_id, $range_start, $range_end, $granularity)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCampaignAnalyticsAsyncWithHttpInfo
     *
     * Get analytics of campaigns
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  string $granularity The time interval between the results in the returned time-series. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCampaignAnalyticsAsyncWithHttpInfo($application_id, $campaign_id, $range_start, $range_end, $granularity = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20011';
        $request = $this->getCampaignAnalyticsRequest($application_id, $campaign_id, $range_start, $range_end, $granularity);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCampaignAnalytics'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  string $granularity The time interval between the results in the returned time-series. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCampaignAnalyticsRequest($application_id, $campaign_id, $range_start, $range_end, $granularity = null)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getCampaignAnalytics'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling getCampaignAnalytics'
            );
        }
        // verify the required parameter 'range_start' is set
        if ($range_start === null || (is_array($range_start) && count($range_start) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $range_start when calling getCampaignAnalytics'
            );
        }
        // verify the required parameter 'range_end' is set
        if ($range_end === null || (is_array($range_end) && count($range_end) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $range_end when calling getCampaignAnalytics'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}/analytics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($range_start !== null) {
            $queryParams['rangeStart'] = ObjectSerializer::toQueryValue($range_start);
        }
        // query params
        if ($range_end !== null) {
            $queryParams['rangeEnd'] = ObjectSerializer::toQueryValue($range_end);
        }
        // query params
        if ($granularity !== null) {
            $queryParams['granularity'] = ObjectSerializer::toQueryValue($granularity);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCampaignByAttributes
     *
     * Get a list of all campaigns that match the given attributes
     *
     * @param  int $application_id application_id (required)
     * @param  \TalonOne\Client\Model\CampaignSearch $body body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse2003
     */
    public function getCampaignByAttributes($application_id, $body, $page_size = null, $skip = null, $sort = null, $campaign_state = null)
    {
        list($response) = $this->getCampaignByAttributesWithHttpInfo($application_id, $body, $page_size, $skip, $sort, $campaign_state);
        return $response;
    }

    /**
     * Operation getCampaignByAttributesWithHttpInfo
     *
     * Get a list of all campaigns that match the given attributes
     *
     * @param  int $application_id (required)
     * @param  \TalonOne\Client\Model\CampaignSearch $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCampaignByAttributesWithHttpInfo($application_id, $body, $page_size = null, $skip = null, $sort = null, $campaign_state = null)
    {
        $request = $this->getCampaignByAttributesRequest($application_id, $body, $page_size, $skip, $sort, $campaign_state);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse2003' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse2003', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse2003';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse2003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCampaignByAttributesAsync
     *
     * Get a list of all campaigns that match the given attributes
     *
     * @param  int $application_id (required)
     * @param  \TalonOne\Client\Model\CampaignSearch $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCampaignByAttributesAsync($application_id, $body, $page_size = null, $skip = null, $sort = null, $campaign_state = null)
    {
        return $this->getCampaignByAttributesAsyncWithHttpInfo($application_id, $body, $page_size, $skip, $sort, $campaign_state)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCampaignByAttributesAsyncWithHttpInfo
     *
     * Get a list of all campaigns that match the given attributes
     *
     * @param  int $application_id (required)
     * @param  \TalonOne\Client\Model\CampaignSearch $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCampaignByAttributesAsyncWithHttpInfo($application_id, $body, $page_size = null, $skip = null, $sort = null, $campaign_state = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse2003';
        $request = $this->getCampaignByAttributesRequest($application_id, $body, $page_size, $skip, $sort, $campaign_state);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCampaignByAttributes'
     *
     * @param  int $application_id (required)
     * @param  \TalonOne\Client\Model\CampaignSearch $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCampaignByAttributesRequest($application_id, $body, $page_size = null, $skip = null, $sort = null, $campaign_state = null)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getCampaignByAttributes'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling getCampaignByAttributes'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns_search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($campaign_state !== null) {
            $queryParams['campaignState'] = ObjectSerializer::toQueryValue($campaign_state);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCampaignSet
     *
     * List CampaignSet
     *
     * @param  int $application_id application_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\CampaignSet
     */
    public function getCampaignSet($application_id)
    {
        list($response) = $this->getCampaignSetWithHttpInfo($application_id);
        return $response;
    }

    /**
     * Operation getCampaignSetWithHttpInfo
     *
     * List CampaignSet
     *
     * @param  int $application_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\CampaignSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCampaignSetWithHttpInfo($application_id)
    {
        $request = $this->getCampaignSetRequest($application_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\CampaignSet' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\CampaignSet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\CampaignSet';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\CampaignSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCampaignSetAsync
     *
     * List CampaignSet
     *
     * @param  int $application_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCampaignSetAsync($application_id)
    {
        return $this->getCampaignSetAsyncWithHttpInfo($application_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCampaignSetAsyncWithHttpInfo
     *
     * List CampaignSet
     *
     * @param  int $application_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCampaignSetAsyncWithHttpInfo($application_id)
    {
        $returnType = '\TalonOne\Client\Model\CampaignSet';
        $request = $this->getCampaignSetRequest($application_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCampaignSet'
     *
     * @param  int $application_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCampaignSetRequest($application_id)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getCampaignSet'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaign_set';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCampaigns
     *
     * List your Campaigns
     *
     * @param  int $application_id application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     * @param  string $name Filter results performing case-insensitive matching against the name of the campaign. (optional)
     * @param  string $tags Filter results performing case-insensitive matching against the tags of the campaign. When used in conjunction with the \&quot;name\&quot; query parameter, a logical OR will be performed to search both tags and name for the provided values (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse2003
     */
    public function getCampaigns($application_id, $page_size = null, $skip = null, $sort = null, $campaign_state = null, $name = null, $tags = null, $created_before = null, $created_after = null)
    {
        list($response) = $this->getCampaignsWithHttpInfo($application_id, $page_size, $skip, $sort, $campaign_state, $name, $tags, $created_before, $created_after);
        return $response;
    }

    /**
     * Operation getCampaignsWithHttpInfo
     *
     * List your Campaigns
     *
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     * @param  string $name Filter results performing case-insensitive matching against the name of the campaign. (optional)
     * @param  string $tags Filter results performing case-insensitive matching against the tags of the campaign. When used in conjunction with the \&quot;name\&quot; query parameter, a logical OR will be performed to search both tags and name for the provided values (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCampaignsWithHttpInfo($application_id, $page_size = null, $skip = null, $sort = null, $campaign_state = null, $name = null, $tags = null, $created_before = null, $created_after = null)
    {
        $request = $this->getCampaignsRequest($application_id, $page_size, $skip, $sort, $campaign_state, $name, $tags, $created_before, $created_after);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse2003' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse2003', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse2003';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse2003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCampaignsAsync
     *
     * List your Campaigns
     *
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     * @param  string $name Filter results performing case-insensitive matching against the name of the campaign. (optional)
     * @param  string $tags Filter results performing case-insensitive matching against the tags of the campaign. When used in conjunction with the \&quot;name\&quot; query parameter, a logical OR will be performed to search both tags and name for the provided values (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCampaignsAsync($application_id, $page_size = null, $skip = null, $sort = null, $campaign_state = null, $name = null, $tags = null, $created_before = null, $created_after = null)
    {
        return $this->getCampaignsAsyncWithHttpInfo($application_id, $page_size, $skip, $sort, $campaign_state, $name, $tags, $created_before, $created_after)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCampaignsAsyncWithHttpInfo
     *
     * List your Campaigns
     *
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     * @param  string $name Filter results performing case-insensitive matching against the name of the campaign. (optional)
     * @param  string $tags Filter results performing case-insensitive matching against the tags of the campaign. When used in conjunction with the \&quot;name\&quot; query parameter, a logical OR will be performed to search both tags and name for the provided values (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCampaignsAsyncWithHttpInfo($application_id, $page_size = null, $skip = null, $sort = null, $campaign_state = null, $name = null, $tags = null, $created_before = null, $created_after = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse2003';
        $request = $this->getCampaignsRequest($application_id, $page_size, $skip, $sort, $campaign_state, $name, $tags, $created_before, $created_after);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCampaigns'
     *
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     * @param  string $name Filter results performing case-insensitive matching against the name of the campaign. (optional)
     * @param  string $tags Filter results performing case-insensitive matching against the tags of the campaign. When used in conjunction with the \&quot;name\&quot; query parameter, a logical OR will be performed to search both tags and name for the provided values (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCampaignsRequest($application_id, $page_size = null, $skip = null, $sort = null, $campaign_state = null, $name = null, $tags = null, $created_before = null, $created_after = null)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getCampaigns'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($campaign_state !== null) {
            $queryParams['campaignState'] = ObjectSerializer::toQueryValue($campaign_state);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($tags !== null) {
            $queryParams['tags'] = ObjectSerializer::toQueryValue($tags);
        }
        // query params
        if ($created_before !== null) {
            $queryParams['createdBefore'] = ObjectSerializer::toQueryValue($created_before);
        }
        // query params
        if ($created_after !== null) {
            $queryParams['createdAfter'] = ObjectSerializer::toQueryValue($created_after);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getChanges
     *
     * Get audit log for an account
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  int $application_id application_id (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the change creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the change creation timestamp. (optional)
     * @param  bool $with_total_result_size When this flag is set, the result will include the total size of the result, across all pages. This might decrease performance on large data sets. With this flag set to true, hasMore will be be true whenever there is a next page. totalResultSize will always be zero. With this flag set to false, hasMore will always be set to false. totalResultSize will contain the total number of results for this query. (optional)
     * @param  bool $include_old When this flag is set to false, the state without the change will not be returned. The default value is true. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20027
     */
    public function getChanges($page_size = null, $skip = null, $sort = null, $application_id = null, $created_before = null, $created_after = null, $with_total_result_size = null, $include_old = null)
    {
        list($response) = $this->getChangesWithHttpInfo($page_size, $skip, $sort, $application_id, $created_before, $created_after, $with_total_result_size, $include_old);
        return $response;
    }

    /**
     * Operation getChangesWithHttpInfo
     *
     * Get audit log for an account
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  int $application_id (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the change creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the change creation timestamp. (optional)
     * @param  bool $with_total_result_size When this flag is set, the result will include the total size of the result, across all pages. This might decrease performance on large data sets. With this flag set to true, hasMore will be be true whenever there is a next page. totalResultSize will always be zero. With this flag set to false, hasMore will always be set to false. totalResultSize will contain the total number of results for this query. (optional)
     * @param  bool $include_old When this flag is set to false, the state without the change will not be returned. The default value is true. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20027, HTTP status code, HTTP response headers (array of strings)
     */
    public function getChangesWithHttpInfo($page_size = null, $skip = null, $sort = null, $application_id = null, $created_before = null, $created_after = null, $with_total_result_size = null, $include_old = null)
    {
        $request = $this->getChangesRequest($page_size, $skip, $sort, $application_id, $created_before, $created_after, $with_total_result_size, $include_old);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20027' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20027', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20027';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20027',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getChangesAsync
     *
     * Get audit log for an account
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  int $application_id (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the change creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the change creation timestamp. (optional)
     * @param  bool $with_total_result_size When this flag is set, the result will include the total size of the result, across all pages. This might decrease performance on large data sets. With this flag set to true, hasMore will be be true whenever there is a next page. totalResultSize will always be zero. With this flag set to false, hasMore will always be set to false. totalResultSize will contain the total number of results for this query. (optional)
     * @param  bool $include_old When this flag is set to false, the state without the change will not be returned. The default value is true. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChangesAsync($page_size = null, $skip = null, $sort = null, $application_id = null, $created_before = null, $created_after = null, $with_total_result_size = null, $include_old = null)
    {
        return $this->getChangesAsyncWithHttpInfo($page_size, $skip, $sort, $application_id, $created_before, $created_after, $with_total_result_size, $include_old)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChangesAsyncWithHttpInfo
     *
     * Get audit log for an account
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  int $application_id (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the change creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the change creation timestamp. (optional)
     * @param  bool $with_total_result_size When this flag is set, the result will include the total size of the result, across all pages. This might decrease performance on large data sets. With this flag set to true, hasMore will be be true whenever there is a next page. totalResultSize will always be zero. With this flag set to false, hasMore will always be set to false. totalResultSize will contain the total number of results for this query. (optional)
     * @param  bool $include_old When this flag is set to false, the state without the change will not be returned. The default value is true. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChangesAsyncWithHttpInfo($page_size = null, $skip = null, $sort = null, $application_id = null, $created_before = null, $created_after = null, $with_total_result_size = null, $include_old = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20027';
        $request = $this->getChangesRequest($page_size, $skip, $sort, $application_id, $created_before, $created_after, $with_total_result_size, $include_old);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getChanges'
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  int $application_id (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the change creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the change creation timestamp. (optional)
     * @param  bool $with_total_result_size When this flag is set, the result will include the total size of the result, across all pages. This might decrease performance on large data sets. With this flag set to true, hasMore will be be true whenever there is a next page. totalResultSize will always be zero. With this flag set to false, hasMore will always be set to false. totalResultSize will contain the total number of results for this query. (optional)
     * @param  bool $include_old When this flag is set to false, the state without the change will not be returned. The default value is true. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getChangesRequest($page_size = null, $skip = null, $sort = null, $application_id = null, $created_before = null, $created_after = null, $with_total_result_size = null, $include_old = null)
    {

        $resourcePath = '/v1/changes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($application_id !== null) {
            $queryParams['applicationId'] = ObjectSerializer::toQueryValue($application_id);
        }
        // query params
        if ($created_before !== null) {
            $queryParams['createdBefore'] = ObjectSerializer::toQueryValue($created_before);
        }
        // query params
        if ($created_after !== null) {
            $queryParams['createdAfter'] = ObjectSerializer::toQueryValue($created_after);
        }
        // query params
        if ($with_total_result_size !== null) {
            $queryParams['withTotalResultSize'] = ObjectSerializer::toQueryValue($with_total_result_size);
        }
        // query params
        if ($include_old !== null) {
            $queryParams['includeOld'] = ObjectSerializer::toQueryValue($include_old);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCoupons
     *
     * List Coupons
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $starts_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $starts_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $expires_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $expires_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse2001
     */
    public function getCoupons($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $starts_after = null, $starts_before = null, $expires_after = null, $expires_before = null, $valid = null, $batch_id = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false)
    {
        list($response) = $this->getCouponsWithHttpInfo($application_id, $campaign_id, $page_size, $skip, $sort, $value, $created_before, $created_after, $starts_after, $starts_before, $expires_after, $expires_before, $valid, $batch_id, $usable, $referral_id, $recipient_integration_id, $exact_match);
        return $response;
    }

    /**
     * Operation getCouponsWithHttpInfo
     *
     * List Coupons
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $starts_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $starts_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $expires_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $expires_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCouponsWithHttpInfo($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $starts_after = null, $starts_before = null, $expires_after = null, $expires_before = null, $valid = null, $batch_id = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false)
    {
        $request = $this->getCouponsRequest($application_id, $campaign_id, $page_size, $skip, $sort, $value, $created_before, $created_after, $starts_after, $starts_before, $expires_after, $expires_before, $valid, $batch_id, $usable, $referral_id, $recipient_integration_id, $exact_match);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse2001' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse2001', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse2001';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse2001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCouponsAsync
     *
     * List Coupons
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $starts_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $starts_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $expires_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $expires_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCouponsAsync($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $starts_after = null, $starts_before = null, $expires_after = null, $expires_before = null, $valid = null, $batch_id = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false)
    {
        return $this->getCouponsAsyncWithHttpInfo($application_id, $campaign_id, $page_size, $skip, $sort, $value, $created_before, $created_after, $starts_after, $starts_before, $expires_after, $expires_before, $valid, $batch_id, $usable, $referral_id, $recipient_integration_id, $exact_match)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCouponsAsyncWithHttpInfo
     *
     * List Coupons
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $starts_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $starts_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $expires_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $expires_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCouponsAsyncWithHttpInfo($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $starts_after = null, $starts_before = null, $expires_after = null, $expires_before = null, $valid = null, $batch_id = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse2001';
        $request = $this->getCouponsRequest($application_id, $campaign_id, $page_size, $skip, $sort, $value, $created_before, $created_after, $starts_after, $starts_before, $expires_after, $expires_before, $valid, $batch_id, $usable, $referral_id, $recipient_integration_id, $exact_match);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCoupons'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $starts_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $starts_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $expires_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $expires_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCouponsRequest($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $starts_after = null, $starts_before = null, $expires_after = null, $expires_before = null, $valid = null, $batch_id = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getCoupons'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling getCoupons'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($value !== null) {
            $queryParams['value'] = ObjectSerializer::toQueryValue($value);
        }
        // query params
        if ($created_before !== null) {
            $queryParams['createdBefore'] = ObjectSerializer::toQueryValue($created_before);
        }
        // query params
        if ($created_after !== null) {
            $queryParams['createdAfter'] = ObjectSerializer::toQueryValue($created_after);
        }
        // query params
        if ($starts_after !== null) {
            $queryParams['startsAfter'] = ObjectSerializer::toQueryValue($starts_after);
        }
        // query params
        if ($starts_before !== null) {
            $queryParams['startsBefore'] = ObjectSerializer::toQueryValue($starts_before);
        }
        // query params
        if ($expires_after !== null) {
            $queryParams['expiresAfter'] = ObjectSerializer::toQueryValue($expires_after);
        }
        // query params
        if ($expires_before !== null) {
            $queryParams['expiresBefore'] = ObjectSerializer::toQueryValue($expires_before);
        }
        // query params
        if ($valid !== null) {
            $queryParams['valid'] = ObjectSerializer::toQueryValue($valid);
        }
        // query params
        if ($batch_id !== null) {
            $queryParams['batchId'] = ObjectSerializer::toQueryValue($batch_id);
        }
        // query params
        if ($usable !== null) {
            $queryParams['usable'] = ObjectSerializer::toQueryValue($usable);
        }
        // query params
        if ($referral_id !== null) {
            $queryParams['referralId'] = ObjectSerializer::toQueryValue($referral_id);
        }
        // query params
        if ($recipient_integration_id !== null) {
            $queryParams['recipientIntegrationId'] = ObjectSerializer::toQueryValue($recipient_integration_id);
        }
        // query params
        if ($exact_match !== null) {
            $queryParams['exactMatch'] = ObjectSerializer::toQueryValue($exact_match);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCouponsByAttributes
     *
     * Get a list of the coupons that match the given attributes
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  \TalonOne\Client\Model\CouponSearch $body body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse2001
     */
    public function getCouponsByAttributes($application_id, $campaign_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false, $batch_id = null)
    {
        list($response) = $this->getCouponsByAttributesWithHttpInfo($application_id, $campaign_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $exact_match, $batch_id);
        return $response;
    }

    /**
     * Operation getCouponsByAttributesWithHttpInfo
     *
     * Get a list of the coupons that match the given attributes
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\CouponSearch $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCouponsByAttributesWithHttpInfo($application_id, $campaign_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false, $batch_id = null)
    {
        $request = $this->getCouponsByAttributesRequest($application_id, $campaign_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $exact_match, $batch_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse2001' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse2001', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse2001';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse2001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCouponsByAttributesAsync
     *
     * Get a list of the coupons that match the given attributes
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\CouponSearch $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCouponsByAttributesAsync($application_id, $campaign_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false, $batch_id = null)
    {
        return $this->getCouponsByAttributesAsyncWithHttpInfo($application_id, $campaign_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $exact_match, $batch_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCouponsByAttributesAsyncWithHttpInfo
     *
     * Get a list of the coupons that match the given attributes
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\CouponSearch $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCouponsByAttributesAsyncWithHttpInfo($application_id, $campaign_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false, $batch_id = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse2001';
        $request = $this->getCouponsByAttributesRequest($application_id, $campaign_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $exact_match, $batch_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCouponsByAttributes'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\CouponSearch $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCouponsByAttributesRequest($application_id, $campaign_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false, $batch_id = null)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getCouponsByAttributes'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling getCouponsByAttributes'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling getCouponsByAttributes'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons_search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($value !== null) {
            $queryParams['value'] = ObjectSerializer::toQueryValue($value);
        }
        // query params
        if ($created_before !== null) {
            $queryParams['createdBefore'] = ObjectSerializer::toQueryValue($created_before);
        }
        // query params
        if ($created_after !== null) {
            $queryParams['createdAfter'] = ObjectSerializer::toQueryValue($created_after);
        }
        // query params
        if ($valid !== null) {
            $queryParams['valid'] = ObjectSerializer::toQueryValue($valid);
        }
        // query params
        if ($usable !== null) {
            $queryParams['usable'] = ObjectSerializer::toQueryValue($usable);
        }
        // query params
        if ($referral_id !== null) {
            $queryParams['referralId'] = ObjectSerializer::toQueryValue($referral_id);
        }
        // query params
        if ($recipient_integration_id !== null) {
            $queryParams['recipientIntegrationId'] = ObjectSerializer::toQueryValue($recipient_integration_id);
        }
        // query params
        if ($exact_match !== null) {
            $queryParams['exactMatch'] = ObjectSerializer::toQueryValue($exact_match);
        }
        // query params
        if ($batch_id !== null) {
            $queryParams['batchId'] = ObjectSerializer::toQueryValue($batch_id);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCouponsByAttributesApplicationWide
     *
     * Get a list of the coupons that match the given attributes in all active campaigns of an application
     *
     * @param  int $application_id application_id (required)
     * @param  \TalonOne\Client\Model\CouponSearch $body body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse2001
     */
    public function getCouponsByAttributesApplicationWide($application_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $batch_id = null, $exact_match = false, $campaign_state = null)
    {
        list($response) = $this->getCouponsByAttributesApplicationWideWithHttpInfo($application_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $batch_id, $exact_match, $campaign_state);
        return $response;
    }

    /**
     * Operation getCouponsByAttributesApplicationWideWithHttpInfo
     *
     * Get a list of the coupons that match the given attributes in all active campaigns of an application
     *
     * @param  int $application_id (required)
     * @param  \TalonOne\Client\Model\CouponSearch $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCouponsByAttributesApplicationWideWithHttpInfo($application_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $batch_id = null, $exact_match = false, $campaign_state = null)
    {
        $request = $this->getCouponsByAttributesApplicationWideRequest($application_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $batch_id, $exact_match, $campaign_state);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse2001' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse2001', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse2001';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse2001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCouponsByAttributesApplicationWideAsync
     *
     * Get a list of the coupons that match the given attributes in all active campaigns of an application
     *
     * @param  int $application_id (required)
     * @param  \TalonOne\Client\Model\CouponSearch $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCouponsByAttributesApplicationWideAsync($application_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $batch_id = null, $exact_match = false, $campaign_state = null)
    {
        return $this->getCouponsByAttributesApplicationWideAsyncWithHttpInfo($application_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $batch_id, $exact_match, $campaign_state)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCouponsByAttributesApplicationWideAsyncWithHttpInfo
     *
     * Get a list of the coupons that match the given attributes in all active campaigns of an application
     *
     * @param  int $application_id (required)
     * @param  \TalonOne\Client\Model\CouponSearch $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCouponsByAttributesApplicationWideAsyncWithHttpInfo($application_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $batch_id = null, $exact_match = false, $campaign_state = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse2001';
        $request = $this->getCouponsByAttributesApplicationWideRequest($application_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $batch_id, $exact_match, $campaign_state);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCouponsByAttributesApplicationWide'
     *
     * @param  int $application_id (required)
     * @param  \TalonOne\Client\Model\CouponSearch $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCouponsByAttributesApplicationWideRequest($application_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $batch_id = null, $exact_match = false, $campaign_state = null)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getCouponsByAttributesApplicationWide'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling getCouponsByAttributesApplicationWide'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/coupons_search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($value !== null) {
            $queryParams['value'] = ObjectSerializer::toQueryValue($value);
        }
        // query params
        if ($created_before !== null) {
            $queryParams['createdBefore'] = ObjectSerializer::toQueryValue($created_before);
        }
        // query params
        if ($created_after !== null) {
            $queryParams['createdAfter'] = ObjectSerializer::toQueryValue($created_after);
        }
        // query params
        if ($valid !== null) {
            $queryParams['valid'] = ObjectSerializer::toQueryValue($valid);
        }
        // query params
        if ($usable !== null) {
            $queryParams['usable'] = ObjectSerializer::toQueryValue($usable);
        }
        // query params
        if ($referral_id !== null) {
            $queryParams['referralId'] = ObjectSerializer::toQueryValue($referral_id);
        }
        // query params
        if ($recipient_integration_id !== null) {
            $queryParams['recipientIntegrationId'] = ObjectSerializer::toQueryValue($recipient_integration_id);
        }
        // query params
        if ($batch_id !== null) {
            $queryParams['batchId'] = ObjectSerializer::toQueryValue($batch_id);
        }
        // query params
        if ($exact_match !== null) {
            $queryParams['exactMatch'] = ObjectSerializer::toQueryValue($exact_match);
        }
        // query params
        if ($campaign_state !== null) {
            $queryParams['campaignState'] = ObjectSerializer::toQueryValue($campaign_state);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCouponsWithoutTotalCount
     *
     * List Coupons
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse2005
     */
    public function getCouponsWithoutTotalCount($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $batch_id = null, $exact_match = false)
    {
        list($response) = $this->getCouponsWithoutTotalCountWithHttpInfo($application_id, $campaign_id, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $batch_id, $exact_match);
        return $response;
    }

    /**
     * Operation getCouponsWithoutTotalCountWithHttpInfo
     *
     * List Coupons
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse2005, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCouponsWithoutTotalCountWithHttpInfo($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $batch_id = null, $exact_match = false)
    {
        $request = $this->getCouponsWithoutTotalCountRequest($application_id, $campaign_id, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $batch_id, $exact_match);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse2005' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse2005', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse2005';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse2005',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCouponsWithoutTotalCountAsync
     *
     * List Coupons
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCouponsWithoutTotalCountAsync($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $batch_id = null, $exact_match = false)
    {
        return $this->getCouponsWithoutTotalCountAsyncWithHttpInfo($application_id, $campaign_id, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $batch_id, $exact_match)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCouponsWithoutTotalCountAsyncWithHttpInfo
     *
     * List Coupons
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCouponsWithoutTotalCountAsyncWithHttpInfo($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $batch_id = null, $exact_match = false)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse2005';
        $request = $this->getCouponsWithoutTotalCountRequest($application_id, $campaign_id, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $batch_id, $exact_match);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCouponsWithoutTotalCount'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCouponsWithoutTotalCountRequest($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $batch_id = null, $exact_match = false)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getCouponsWithoutTotalCount'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling getCouponsWithoutTotalCount'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons/no_total';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($value !== null) {
            $queryParams['value'] = ObjectSerializer::toQueryValue($value);
        }
        // query params
        if ($created_before !== null) {
            $queryParams['createdBefore'] = ObjectSerializer::toQueryValue($created_before);
        }
        // query params
        if ($created_after !== null) {
            $queryParams['createdAfter'] = ObjectSerializer::toQueryValue($created_after);
        }
        // query params
        if ($valid !== null) {
            $queryParams['valid'] = ObjectSerializer::toQueryValue($valid);
        }
        // query params
        if ($usable !== null) {
            $queryParams['usable'] = ObjectSerializer::toQueryValue($usable);
        }
        // query params
        if ($referral_id !== null) {
            $queryParams['referralId'] = ObjectSerializer::toQueryValue($referral_id);
        }
        // query params
        if ($recipient_integration_id !== null) {
            $queryParams['recipientIntegrationId'] = ObjectSerializer::toQueryValue($recipient_integration_id);
        }
        // query params
        if ($batch_id !== null) {
            $queryParams['batchId'] = ObjectSerializer::toQueryValue($batch_id);
        }
        // query params
        if ($exact_match !== null) {
            $queryParams['exactMatch'] = ObjectSerializer::toQueryValue($exact_match);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCustomerActivityReport
     *
     * Get Activity Report for Single Customer
     *
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  int $application_id application_id (required)
     * @param  int $customer_id customer_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\CustomerActivityReport
     */
    public function getCustomerActivityReport($range_start, $range_end, $application_id, $customer_id, $page_size = null, $skip = null)
    {
        list($response) = $this->getCustomerActivityReportWithHttpInfo($range_start, $range_end, $application_id, $customer_id, $page_size, $skip);
        return $response;
    }

    /**
     * Operation getCustomerActivityReportWithHttpInfo
     *
     * Get Activity Report for Single Customer
     *
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  int $application_id (required)
     * @param  int $customer_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\CustomerActivityReport, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCustomerActivityReportWithHttpInfo($range_start, $range_end, $application_id, $customer_id, $page_size = null, $skip = null)
    {
        $request = $this->getCustomerActivityReportRequest($range_start, $range_end, $application_id, $customer_id, $page_size, $skip);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\CustomerActivityReport' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\CustomerActivityReport', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\CustomerActivityReport';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\CustomerActivityReport',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCustomerActivityReportAsync
     *
     * Get Activity Report for Single Customer
     *
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  int $application_id (required)
     * @param  int $customer_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerActivityReportAsync($range_start, $range_end, $application_id, $customer_id, $page_size = null, $skip = null)
    {
        return $this->getCustomerActivityReportAsyncWithHttpInfo($range_start, $range_end, $application_id, $customer_id, $page_size, $skip)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCustomerActivityReportAsyncWithHttpInfo
     *
     * Get Activity Report for Single Customer
     *
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  int $application_id (required)
     * @param  int $customer_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerActivityReportAsyncWithHttpInfo($range_start, $range_end, $application_id, $customer_id, $page_size = null, $skip = null)
    {
        $returnType = '\TalonOne\Client\Model\CustomerActivityReport';
        $request = $this->getCustomerActivityReportRequest($range_start, $range_end, $application_id, $customer_id, $page_size, $skip);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCustomerActivityReport'
     *
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  int $application_id (required)
     * @param  int $customer_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCustomerActivityReportRequest($range_start, $range_end, $application_id, $customer_id, $page_size = null, $skip = null)
    {
        // verify the required parameter 'range_start' is set
        if ($range_start === null || (is_array($range_start) && count($range_start) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $range_start when calling getCustomerActivityReport'
            );
        }
        // verify the required parameter 'range_end' is set
        if ($range_end === null || (is_array($range_end) && count($range_end) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $range_end when calling getCustomerActivityReport'
            );
        }
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getCustomerActivityReport'
            );
        }
        // verify the required parameter 'customer_id' is set
        if ($customer_id === null || (is_array($customer_id) && count($customer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customer_id when calling getCustomerActivityReport'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/customer_activity_reports/{customerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($range_start !== null) {
            $queryParams['rangeStart'] = ObjectSerializer::toQueryValue($range_start);
        }
        // query params
        if ($range_end !== null) {
            $queryParams['rangeEnd'] = ObjectSerializer::toQueryValue($range_end);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($customer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'customerId' . '}',
                ObjectSerializer::toPathValue($customer_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCustomerActivityReports
     *
     * Get Activity Reports for Application Customers
     *
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  int $application_id application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $name Only return reports matching the customer name (optional)
     * @param  string $integration_id Only return reports matching the integrationId (optional)
     * @param  string $campaign_name Only return reports matching the campaignName (optional)
     * @param  string $advocate_name Only return reports matching the current customer referrer name (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20014
     */
    public function getCustomerActivityReports($range_start, $range_end, $application_id, $page_size = null, $skip = null, $sort = null, $name = null, $integration_id = null, $campaign_name = null, $advocate_name = null)
    {
        list($response) = $this->getCustomerActivityReportsWithHttpInfo($range_start, $range_end, $application_id, $page_size, $skip, $sort, $name, $integration_id, $campaign_name, $advocate_name);
        return $response;
    }

    /**
     * Operation getCustomerActivityReportsWithHttpInfo
     *
     * Get Activity Reports for Application Customers
     *
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $name Only return reports matching the customer name (optional)
     * @param  string $integration_id Only return reports matching the integrationId (optional)
     * @param  string $campaign_name Only return reports matching the campaignName (optional)
     * @param  string $advocate_name Only return reports matching the current customer referrer name (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20014, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCustomerActivityReportsWithHttpInfo($range_start, $range_end, $application_id, $page_size = null, $skip = null, $sort = null, $name = null, $integration_id = null, $campaign_name = null, $advocate_name = null)
    {
        $request = $this->getCustomerActivityReportsRequest($range_start, $range_end, $application_id, $page_size, $skip, $sort, $name, $integration_id, $campaign_name, $advocate_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20014' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20014', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20014';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20014',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCustomerActivityReportsAsync
     *
     * Get Activity Reports for Application Customers
     *
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $name Only return reports matching the customer name (optional)
     * @param  string $integration_id Only return reports matching the integrationId (optional)
     * @param  string $campaign_name Only return reports matching the campaignName (optional)
     * @param  string $advocate_name Only return reports matching the current customer referrer name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerActivityReportsAsync($range_start, $range_end, $application_id, $page_size = null, $skip = null, $sort = null, $name = null, $integration_id = null, $campaign_name = null, $advocate_name = null)
    {
        return $this->getCustomerActivityReportsAsyncWithHttpInfo($range_start, $range_end, $application_id, $page_size, $skip, $sort, $name, $integration_id, $campaign_name, $advocate_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCustomerActivityReportsAsyncWithHttpInfo
     *
     * Get Activity Reports for Application Customers
     *
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $name Only return reports matching the customer name (optional)
     * @param  string $integration_id Only return reports matching the integrationId (optional)
     * @param  string $campaign_name Only return reports matching the campaignName (optional)
     * @param  string $advocate_name Only return reports matching the current customer referrer name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerActivityReportsAsyncWithHttpInfo($range_start, $range_end, $application_id, $page_size = null, $skip = null, $sort = null, $name = null, $integration_id = null, $campaign_name = null, $advocate_name = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20014';
        $request = $this->getCustomerActivityReportsRequest($range_start, $range_end, $application_id, $page_size, $skip, $sort, $name, $integration_id, $campaign_name, $advocate_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCustomerActivityReports'
     *
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $name Only return reports matching the customer name (optional)
     * @param  string $integration_id Only return reports matching the integrationId (optional)
     * @param  string $campaign_name Only return reports matching the campaignName (optional)
     * @param  string $advocate_name Only return reports matching the current customer referrer name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCustomerActivityReportsRequest($range_start, $range_end, $application_id, $page_size = null, $skip = null, $sort = null, $name = null, $integration_id = null, $campaign_name = null, $advocate_name = null)
    {
        // verify the required parameter 'range_start' is set
        if ($range_start === null || (is_array($range_start) && count($range_start) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $range_start when calling getCustomerActivityReports'
            );
        }
        // verify the required parameter 'range_end' is set
        if ($range_end === null || (is_array($range_end) && count($range_end) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $range_end when calling getCustomerActivityReports'
            );
        }
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getCustomerActivityReports'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/customer_activity_reports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($range_start !== null) {
            $queryParams['rangeStart'] = ObjectSerializer::toQueryValue($range_start);
        }
        // query params
        if ($range_end !== null) {
            $queryParams['rangeEnd'] = ObjectSerializer::toQueryValue($range_end);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($integration_id !== null) {
            $queryParams['integrationId'] = ObjectSerializer::toQueryValue($integration_id);
        }
        // query params
        if ($campaign_name !== null) {
            $queryParams['campaignName'] = ObjectSerializer::toQueryValue($campaign_name);
        }
        // query params
        if ($advocate_name !== null) {
            $queryParams['advocateName'] = ObjectSerializer::toQueryValue($advocate_name);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCustomerActivityReportsWithoutTotalCount
     *
     * Get Activity Reports for Application Customers
     *
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  int $application_id application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $name Only return reports matching the customer name (optional)
     * @param  string $integration_id Only return reports matching the integrationId (optional)
     * @param  string $campaign_name Only return reports matching the campaignName (optional)
     * @param  string $advocate_name Only return reports matching the current customer referrer name (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20015
     */
    public function getCustomerActivityReportsWithoutTotalCount($range_start, $range_end, $application_id, $page_size = null, $skip = null, $sort = null, $name = null, $integration_id = null, $campaign_name = null, $advocate_name = null)
    {
        list($response) = $this->getCustomerActivityReportsWithoutTotalCountWithHttpInfo($range_start, $range_end, $application_id, $page_size, $skip, $sort, $name, $integration_id, $campaign_name, $advocate_name);
        return $response;
    }

    /**
     * Operation getCustomerActivityReportsWithoutTotalCountWithHttpInfo
     *
     * Get Activity Reports for Application Customers
     *
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $name Only return reports matching the customer name (optional)
     * @param  string $integration_id Only return reports matching the integrationId (optional)
     * @param  string $campaign_name Only return reports matching the campaignName (optional)
     * @param  string $advocate_name Only return reports matching the current customer referrer name (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20015, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCustomerActivityReportsWithoutTotalCountWithHttpInfo($range_start, $range_end, $application_id, $page_size = null, $skip = null, $sort = null, $name = null, $integration_id = null, $campaign_name = null, $advocate_name = null)
    {
        $request = $this->getCustomerActivityReportsWithoutTotalCountRequest($range_start, $range_end, $application_id, $page_size, $skip, $sort, $name, $integration_id, $campaign_name, $advocate_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20015' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20015', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20015';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20015',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCustomerActivityReportsWithoutTotalCountAsync
     *
     * Get Activity Reports for Application Customers
     *
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $name Only return reports matching the customer name (optional)
     * @param  string $integration_id Only return reports matching the integrationId (optional)
     * @param  string $campaign_name Only return reports matching the campaignName (optional)
     * @param  string $advocate_name Only return reports matching the current customer referrer name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerActivityReportsWithoutTotalCountAsync($range_start, $range_end, $application_id, $page_size = null, $skip = null, $sort = null, $name = null, $integration_id = null, $campaign_name = null, $advocate_name = null)
    {
        return $this->getCustomerActivityReportsWithoutTotalCountAsyncWithHttpInfo($range_start, $range_end, $application_id, $page_size, $skip, $sort, $name, $integration_id, $campaign_name, $advocate_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCustomerActivityReportsWithoutTotalCountAsyncWithHttpInfo
     *
     * Get Activity Reports for Application Customers
     *
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $name Only return reports matching the customer name (optional)
     * @param  string $integration_id Only return reports matching the integrationId (optional)
     * @param  string $campaign_name Only return reports matching the campaignName (optional)
     * @param  string $advocate_name Only return reports matching the current customer referrer name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerActivityReportsWithoutTotalCountAsyncWithHttpInfo($range_start, $range_end, $application_id, $page_size = null, $skip = null, $sort = null, $name = null, $integration_id = null, $campaign_name = null, $advocate_name = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20015';
        $request = $this->getCustomerActivityReportsWithoutTotalCountRequest($range_start, $range_end, $application_id, $page_size, $skip, $sort, $name, $integration_id, $campaign_name, $advocate_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCustomerActivityReportsWithoutTotalCount'
     *
     * @param  \DateTime $range_start Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
     * @param  \DateTime $range_end Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
     * @param  int $application_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $name Only return reports matching the customer name (optional)
     * @param  string $integration_id Only return reports matching the integrationId (optional)
     * @param  string $campaign_name Only return reports matching the campaignName (optional)
     * @param  string $advocate_name Only return reports matching the current customer referrer name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCustomerActivityReportsWithoutTotalCountRequest($range_start, $range_end, $application_id, $page_size = null, $skip = null, $sort = null, $name = null, $integration_id = null, $campaign_name = null, $advocate_name = null)
    {
        // verify the required parameter 'range_start' is set
        if ($range_start === null || (is_array($range_start) && count($range_start) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $range_start when calling getCustomerActivityReportsWithoutTotalCount'
            );
        }
        // verify the required parameter 'range_end' is set
        if ($range_end === null || (is_array($range_end) && count($range_end) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $range_end when calling getCustomerActivityReportsWithoutTotalCount'
            );
        }
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getCustomerActivityReportsWithoutTotalCount'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/customer_activity_reports/no_total';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($range_start !== null) {
            $queryParams['rangeStart'] = ObjectSerializer::toQueryValue($range_start);
        }
        // query params
        if ($range_end !== null) {
            $queryParams['rangeEnd'] = ObjectSerializer::toQueryValue($range_end);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($integration_id !== null) {
            $queryParams['integrationId'] = ObjectSerializer::toQueryValue($integration_id);
        }
        // query params
        if ($campaign_name !== null) {
            $queryParams['campaignName'] = ObjectSerializer::toQueryValue($campaign_name);
        }
        // query params
        if ($advocate_name !== null) {
            $queryParams['advocateName'] = ObjectSerializer::toQueryValue($advocate_name);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCustomerAnalytics
     *
     * Get Analytics Report for a Customer
     *
     * @param  int $application_id application_id (required)
     * @param  int $customer_id customer_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\CustomerAnalytics
     */
    public function getCustomerAnalytics($application_id, $customer_id, $page_size = null, $skip = null, $sort = null)
    {
        list($response) = $this->getCustomerAnalyticsWithHttpInfo($application_id, $customer_id, $page_size, $skip, $sort);
        return $response;
    }

    /**
     * Operation getCustomerAnalyticsWithHttpInfo
     *
     * Get Analytics Report for a Customer
     *
     * @param  int $application_id (required)
     * @param  int $customer_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\CustomerAnalytics, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCustomerAnalyticsWithHttpInfo($application_id, $customer_id, $page_size = null, $skip = null, $sort = null)
    {
        $request = $this->getCustomerAnalyticsRequest($application_id, $customer_id, $page_size, $skip, $sort);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\CustomerAnalytics' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\CustomerAnalytics', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\CustomerAnalytics';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\CustomerAnalytics',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCustomerAnalyticsAsync
     *
     * Get Analytics Report for a Customer
     *
     * @param  int $application_id (required)
     * @param  int $customer_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerAnalyticsAsync($application_id, $customer_id, $page_size = null, $skip = null, $sort = null)
    {
        return $this->getCustomerAnalyticsAsyncWithHttpInfo($application_id, $customer_id, $page_size, $skip, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCustomerAnalyticsAsyncWithHttpInfo
     *
     * Get Analytics Report for a Customer
     *
     * @param  int $application_id (required)
     * @param  int $customer_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerAnalyticsAsyncWithHttpInfo($application_id, $customer_id, $page_size = null, $skip = null, $sort = null)
    {
        $returnType = '\TalonOne\Client\Model\CustomerAnalytics';
        $request = $this->getCustomerAnalyticsRequest($application_id, $customer_id, $page_size, $skip, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCustomerAnalytics'
     *
     * @param  int $application_id (required)
     * @param  int $customer_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCustomerAnalyticsRequest($application_id, $customer_id, $page_size = null, $skip = null, $sort = null)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getCustomerAnalytics'
            );
        }
        // verify the required parameter 'customer_id' is set
        if ($customer_id === null || (is_array($customer_id) && count($customer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customer_id when calling getCustomerAnalytics'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/customers/{customerId}/analytics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($customer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'customerId' . '}',
                ObjectSerializer::toPathValue($customer_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCustomerProfile
     *
     * Get Customer Profile
     *
     * @param  int $application_id application_id (required)
     * @param  int $customer_id customer_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\ApplicationCustomer
     */
    public function getCustomerProfile($application_id, $customer_id)
    {
        list($response) = $this->getCustomerProfileWithHttpInfo($application_id, $customer_id);
        return $response;
    }

    /**
     * Operation getCustomerProfileWithHttpInfo
     *
     * Get Customer Profile
     *
     * @param  int $application_id (required)
     * @param  int $customer_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\ApplicationCustomer, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCustomerProfileWithHttpInfo($application_id, $customer_id)
    {
        $request = $this->getCustomerProfileRequest($application_id, $customer_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\ApplicationCustomer' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\ApplicationCustomer', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\ApplicationCustomer';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\ApplicationCustomer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCustomerProfileAsync
     *
     * Get Customer Profile
     *
     * @param  int $application_id (required)
     * @param  int $customer_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerProfileAsync($application_id, $customer_id)
    {
        return $this->getCustomerProfileAsyncWithHttpInfo($application_id, $customer_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCustomerProfileAsyncWithHttpInfo
     *
     * Get Customer Profile
     *
     * @param  int $application_id (required)
     * @param  int $customer_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerProfileAsyncWithHttpInfo($application_id, $customer_id)
    {
        $returnType = '\TalonOne\Client\Model\ApplicationCustomer';
        $request = $this->getCustomerProfileRequest($application_id, $customer_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCustomerProfile'
     *
     * @param  int $application_id (required)
     * @param  int $customer_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCustomerProfileRequest($application_id, $customer_id)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getCustomerProfile'
            );
        }
        // verify the required parameter 'customer_id' is set
        if ($customer_id === null || (is_array($customer_id) && count($customer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customer_id when calling getCustomerProfile'
            );
        }

        $resourcePath = '/v1/customers/{customerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($customer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'customerId' . '}',
                ObjectSerializer::toPathValue($customer_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCustomerProfiles
     *
     * List Customer Profiles
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20013
     */
    public function getCustomerProfiles($page_size = null, $skip = null)
    {
        list($response) = $this->getCustomerProfilesWithHttpInfo($page_size, $skip);
        return $response;
    }

    /**
     * Operation getCustomerProfilesWithHttpInfo
     *
     * List Customer Profiles
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20013, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCustomerProfilesWithHttpInfo($page_size = null, $skip = null)
    {
        $request = $this->getCustomerProfilesRequest($page_size, $skip);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20013' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20013', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20013';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20013',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCustomerProfilesAsync
     *
     * List Customer Profiles
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerProfilesAsync($page_size = null, $skip = null)
    {
        return $this->getCustomerProfilesAsyncWithHttpInfo($page_size, $skip)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCustomerProfilesAsyncWithHttpInfo
     *
     * List Customer Profiles
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerProfilesAsyncWithHttpInfo($page_size = null, $skip = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20013';
        $request = $this->getCustomerProfilesRequest($page_size, $skip);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCustomerProfiles'
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCustomerProfilesRequest($page_size = null, $skip = null)
    {

        $resourcePath = '/v1/customers/no_total';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCustomersByAttributes
     *
     * Get a list of the customer profiles that match the given attributes
     *
     * @param  \TalonOne\Client\Model\ApplicationCustomerSearch $body body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20013
     */
    public function getCustomersByAttributes($body, $page_size = null, $skip = null)
    {
        list($response) = $this->getCustomersByAttributesWithHttpInfo($body, $page_size, $skip);
        return $response;
    }

    /**
     * Operation getCustomersByAttributesWithHttpInfo
     *
     * Get a list of the customer profiles that match the given attributes
     *
     * @param  \TalonOne\Client\Model\ApplicationCustomerSearch $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20013, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCustomersByAttributesWithHttpInfo($body, $page_size = null, $skip = null)
    {
        $request = $this->getCustomersByAttributesRequest($body, $page_size, $skip);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20013' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20013', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20013';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20013',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCustomersByAttributesAsync
     *
     * Get a list of the customer profiles that match the given attributes
     *
     * @param  \TalonOne\Client\Model\ApplicationCustomerSearch $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomersByAttributesAsync($body, $page_size = null, $skip = null)
    {
        return $this->getCustomersByAttributesAsyncWithHttpInfo($body, $page_size, $skip)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCustomersByAttributesAsyncWithHttpInfo
     *
     * Get a list of the customer profiles that match the given attributes
     *
     * @param  \TalonOne\Client\Model\ApplicationCustomerSearch $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomersByAttributesAsyncWithHttpInfo($body, $page_size = null, $skip = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20013';
        $request = $this->getCustomersByAttributesRequest($body, $page_size, $skip);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCustomersByAttributes'
     *
     * @param  \TalonOne\Client\Model\ApplicationCustomerSearch $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCustomersByAttributesRequest($body, $page_size = null, $skip = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling getCustomersByAttributes'
            );
        }

        $resourcePath = '/v1/customer_search/no_total';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEventTypes
     *
     * List Event Types
     *
     * @param  string $application_ids Filter by one or more application ids separated by comma (optional)
     * @param  string $name Filter results to event types with the given name. This parameter implies &#x60;includeOldVersions&#x60;. (optional)
     * @param  bool $include_old_versions Include all versions of every event type. (optional, default to false)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20025
     */
    public function getEventTypes($application_ids = null, $name = null, $include_old_versions = false, $page_size = null, $skip = null, $sort = null)
    {
        list($response) = $this->getEventTypesWithHttpInfo($application_ids, $name, $include_old_versions, $page_size, $skip, $sort);
        return $response;
    }

    /**
     * Operation getEventTypesWithHttpInfo
     *
     * List Event Types
     *
     * @param  string $application_ids Filter by one or more application ids separated by comma (optional)
     * @param  string $name Filter results to event types with the given name. This parameter implies &#x60;includeOldVersions&#x60;. (optional)
     * @param  bool $include_old_versions Include all versions of every event type. (optional, default to false)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20025, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEventTypesWithHttpInfo($application_ids = null, $name = null, $include_old_versions = false, $page_size = null, $skip = null, $sort = null)
    {
        $request = $this->getEventTypesRequest($application_ids, $name, $include_old_versions, $page_size, $skip, $sort);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20025' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20025', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20025';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20025',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEventTypesAsync
     *
     * List Event Types
     *
     * @param  string $application_ids Filter by one or more application ids separated by comma (optional)
     * @param  string $name Filter results to event types with the given name. This parameter implies &#x60;includeOldVersions&#x60;. (optional)
     * @param  bool $include_old_versions Include all versions of every event type. (optional, default to false)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEventTypesAsync($application_ids = null, $name = null, $include_old_versions = false, $page_size = null, $skip = null, $sort = null)
    {
        return $this->getEventTypesAsyncWithHttpInfo($application_ids, $name, $include_old_versions, $page_size, $skip, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEventTypesAsyncWithHttpInfo
     *
     * List Event Types
     *
     * @param  string $application_ids Filter by one or more application ids separated by comma (optional)
     * @param  string $name Filter results to event types with the given name. This parameter implies &#x60;includeOldVersions&#x60;. (optional)
     * @param  bool $include_old_versions Include all versions of every event type. (optional, default to false)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEventTypesAsyncWithHttpInfo($application_ids = null, $name = null, $include_old_versions = false, $page_size = null, $skip = null, $sort = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20025';
        $request = $this->getEventTypesRequest($application_ids, $name, $include_old_versions, $page_size, $skip, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEventTypes'
     *
     * @param  string $application_ids Filter by one or more application ids separated by comma (optional)
     * @param  string $name Filter results to event types with the given name. This parameter implies &#x60;includeOldVersions&#x60;. (optional)
     * @param  bool $include_old_versions Include all versions of every event type. (optional, default to false)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEventTypesRequest($application_ids = null, $name = null, $include_old_versions = false, $page_size = null, $skip = null, $sort = null)
    {

        $resourcePath = '/v1/event_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($application_ids !== null) {
            $queryParams['applicationIds'] = ObjectSerializer::toQueryValue($application_ids);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($include_old_versions !== null) {
            $queryParams['includeOldVersions'] = ObjectSerializer::toQueryValue($include_old_versions);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getExports
     *
     * Get Exports
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  int $application_id application_id (optional)
     * @param  int $campaign_id campaign_id (optional)
     * @param  string $entity The name of the entity type that was exported. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20028
     */
    public function getExports($page_size = null, $skip = null, $application_id = null, $campaign_id = null, $entity = null)
    {
        list($response) = $this->getExportsWithHttpInfo($page_size, $skip, $application_id, $campaign_id, $entity);
        return $response;
    }

    /**
     * Operation getExportsWithHttpInfo
     *
     * Get Exports
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  int $application_id (optional)
     * @param  int $campaign_id (optional)
     * @param  string $entity The name of the entity type that was exported. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20028, HTTP status code, HTTP response headers (array of strings)
     */
    public function getExportsWithHttpInfo($page_size = null, $skip = null, $application_id = null, $campaign_id = null, $entity = null)
    {
        $request = $this->getExportsRequest($page_size, $skip, $application_id, $campaign_id, $entity);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20028' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20028', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20028';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20028',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getExportsAsync
     *
     * Get Exports
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  int $application_id (optional)
     * @param  int $campaign_id (optional)
     * @param  string $entity The name of the entity type that was exported. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExportsAsync($page_size = null, $skip = null, $application_id = null, $campaign_id = null, $entity = null)
    {
        return $this->getExportsAsyncWithHttpInfo($page_size, $skip, $application_id, $campaign_id, $entity)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getExportsAsyncWithHttpInfo
     *
     * Get Exports
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  int $application_id (optional)
     * @param  int $campaign_id (optional)
     * @param  string $entity The name of the entity type that was exported. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExportsAsyncWithHttpInfo($page_size = null, $skip = null, $application_id = null, $campaign_id = null, $entity = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20028';
        $request = $this->getExportsRequest($page_size, $skip, $application_id, $campaign_id, $entity);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getExports'
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  int $application_id (optional)
     * @param  int $campaign_id (optional)
     * @param  string $entity The name of the entity type that was exported. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getExportsRequest($page_size = null, $skip = null, $application_id = null, $campaign_id = null, $entity = null)
    {

        $resourcePath = '/v1/exports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($application_id !== null) {
            $queryParams['applicationId'] = ObjectSerializer::toQueryValue($application_id);
        }
        // query params
        if ($campaign_id !== null) {
            $queryParams['campaignId'] = ObjectSerializer::toQueryValue($campaign_id);
        }
        // query params
        if ($entity !== null) {
            $queryParams['entity'] = ObjectSerializer::toQueryValue($entity);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImports
     *
     * Get Imports
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20029
     */
    public function getImports($page_size = null, $skip = null)
    {
        list($response) = $this->getImportsWithHttpInfo($page_size, $skip);
        return $response;
    }

    /**
     * Operation getImportsWithHttpInfo
     *
     * Get Imports
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20029, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImportsWithHttpInfo($page_size = null, $skip = null)
    {
        $request = $this->getImportsRequest($page_size, $skip);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20029' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20029', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20029';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20029',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImportsAsync
     *
     * Get Imports
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImportsAsync($page_size = null, $skip = null)
    {
        return $this->getImportsAsyncWithHttpInfo($page_size, $skip)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImportsAsyncWithHttpInfo
     *
     * Get Imports
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImportsAsyncWithHttpInfo($page_size = null, $skip = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20029';
        $request = $this->getImportsRequest($page_size, $skip);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImports'
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getImportsRequest($page_size = null, $skip = null)
    {

        $resourcePath = '/v1/imports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLoyaltyPoints
     *
     * get the Loyalty Ledger for this integrationID
     *
     * @param  string $program_id The identifier for the application, must be unique within the account. (required)
     * @param  string $integration_id The identifier for the application, must be unique within the account. (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\LoyaltyLedger
     */
    public function getLoyaltyPoints($program_id, $integration_id)
    {
        list($response) = $this->getLoyaltyPointsWithHttpInfo($program_id, $integration_id);
        return $response;
    }

    /**
     * Operation getLoyaltyPointsWithHttpInfo
     *
     * get the Loyalty Ledger for this integrationID
     *
     * @param  string $program_id The identifier for the application, must be unique within the account. (required)
     * @param  string $integration_id The identifier for the application, must be unique within the account. (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\LoyaltyLedger, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLoyaltyPointsWithHttpInfo($program_id, $integration_id)
    {
        $request = $this->getLoyaltyPointsRequest($program_id, $integration_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\LoyaltyLedger' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\LoyaltyLedger', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\LoyaltyLedger';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\LoyaltyLedger',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLoyaltyPointsAsync
     *
     * get the Loyalty Ledger for this integrationID
     *
     * @param  string $program_id The identifier for the application, must be unique within the account. (required)
     * @param  string $integration_id The identifier for the application, must be unique within the account. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLoyaltyPointsAsync($program_id, $integration_id)
    {
        return $this->getLoyaltyPointsAsyncWithHttpInfo($program_id, $integration_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLoyaltyPointsAsyncWithHttpInfo
     *
     * get the Loyalty Ledger for this integrationID
     *
     * @param  string $program_id The identifier for the application, must be unique within the account. (required)
     * @param  string $integration_id The identifier for the application, must be unique within the account. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLoyaltyPointsAsyncWithHttpInfo($program_id, $integration_id)
    {
        $returnType = '\TalonOne\Client\Model\LoyaltyLedger';
        $request = $this->getLoyaltyPointsRequest($program_id, $integration_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLoyaltyPoints'
     *
     * @param  string $program_id The identifier for the application, must be unique within the account. (required)
     * @param  string $integration_id The identifier for the application, must be unique within the account. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLoyaltyPointsRequest($program_id, $integration_id)
    {
        // verify the required parameter 'program_id' is set
        if ($program_id === null || (is_array($program_id) && count($program_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $program_id when calling getLoyaltyPoints'
            );
        }
        // verify the required parameter 'integration_id' is set
        if ($integration_id === null || (is_array($integration_id) && count($integration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $integration_id when calling getLoyaltyPoints'
            );
        }

        $resourcePath = '/v1/loyalty_programs/{programID}/profile/{integrationID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($program_id !== null) {
            $resourcePath = str_replace(
                '{' . 'programID' . '}',
                ObjectSerializer::toPathValue($program_id),
                $resourcePath
            );
        }
        // path params
        if ($integration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'integrationID' . '}',
                ObjectSerializer::toPathValue($integration_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLoyaltyProgram
     *
     * Get a loyalty program
     *
     * @param  string $program_id program_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\LoyaltyProgram
     */
    public function getLoyaltyProgram($program_id)
    {
        list($response) = $this->getLoyaltyProgramWithHttpInfo($program_id);
        return $response;
    }

    /**
     * Operation getLoyaltyProgramWithHttpInfo
     *
     * Get a loyalty program
     *
     * @param  string $program_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\LoyaltyProgram, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLoyaltyProgramWithHttpInfo($program_id)
    {
        $request = $this->getLoyaltyProgramRequest($program_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\LoyaltyProgram' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\LoyaltyProgram', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\LoyaltyProgram';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\LoyaltyProgram',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLoyaltyProgramAsync
     *
     * Get a loyalty program
     *
     * @param  string $program_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLoyaltyProgramAsync($program_id)
    {
        return $this->getLoyaltyProgramAsyncWithHttpInfo($program_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLoyaltyProgramAsyncWithHttpInfo
     *
     * Get a loyalty program
     *
     * @param  string $program_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLoyaltyProgramAsyncWithHttpInfo($program_id)
    {
        $returnType = '\TalonOne\Client\Model\LoyaltyProgram';
        $request = $this->getLoyaltyProgramRequest($program_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLoyaltyProgram'
     *
     * @param  string $program_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLoyaltyProgramRequest($program_id)
    {
        // verify the required parameter 'program_id' is set
        if ($program_id === null || (is_array($program_id) && count($program_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $program_id when calling getLoyaltyProgram'
            );
        }

        $resourcePath = '/v1/loyalty_programs/{programID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($program_id !== null) {
            $resourcePath = str_replace(
                '{' . 'programID' . '}',
                ObjectSerializer::toPathValue($program_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLoyaltyPrograms
     *
     * List all loyalty Programs
     *
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse2008
     */
    public function getLoyaltyPrograms()
    {
        list($response) = $this->getLoyaltyProgramsWithHttpInfo();
        return $response;
    }

    /**
     * Operation getLoyaltyProgramsWithHttpInfo
     *
     * List all loyalty Programs
     *
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse2008, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLoyaltyProgramsWithHttpInfo()
    {
        $request = $this->getLoyaltyProgramsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse2008' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse2008', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse2008';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse2008',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLoyaltyProgramsAsync
     *
     * List all loyalty Programs
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLoyaltyProgramsAsync()
    {
        return $this->getLoyaltyProgramsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLoyaltyProgramsAsyncWithHttpInfo
     *
     * List all loyalty Programs
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLoyaltyProgramsAsyncWithHttpInfo()
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse2008';
        $request = $this->getLoyaltyProgramsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLoyaltyPrograms'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLoyaltyProgramsRequest()
    {

        $resourcePath = '/v1/loyalty_programs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getReferrals
     *
     * List Referrals
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $code Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only referrals where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only referrals where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  string $advocate Filter results by match with a profile id specified in the referral&#39;s AdvocateProfileIntegrationId field (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse2006
     */
    public function getReferrals($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null, $code = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $advocate = null)
    {
        list($response) = $this->getReferralsWithHttpInfo($application_id, $campaign_id, $page_size, $skip, $sort, $code, $created_before, $created_after, $valid, $usable, $advocate);
        return $response;
    }

    /**
     * Operation getReferralsWithHttpInfo
     *
     * List Referrals
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $code Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only referrals where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only referrals where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  string $advocate Filter results by match with a profile id specified in the referral&#39;s AdvocateProfileIntegrationId field (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse2006, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReferralsWithHttpInfo($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null, $code = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $advocate = null)
    {
        $request = $this->getReferralsRequest($application_id, $campaign_id, $page_size, $skip, $sort, $code, $created_before, $created_after, $valid, $usable, $advocate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse2006' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse2006', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse2006';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse2006',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReferralsAsync
     *
     * List Referrals
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $code Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only referrals where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only referrals where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  string $advocate Filter results by match with a profile id specified in the referral&#39;s AdvocateProfileIntegrationId field (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReferralsAsync($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null, $code = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $advocate = null)
    {
        return $this->getReferralsAsyncWithHttpInfo($application_id, $campaign_id, $page_size, $skip, $sort, $code, $created_before, $created_after, $valid, $usable, $advocate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReferralsAsyncWithHttpInfo
     *
     * List Referrals
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $code Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only referrals where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only referrals where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  string $advocate Filter results by match with a profile id specified in the referral&#39;s AdvocateProfileIntegrationId field (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReferralsAsyncWithHttpInfo($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null, $code = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $advocate = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse2006';
        $request = $this->getReferralsRequest($application_id, $campaign_id, $page_size, $skip, $sort, $code, $created_before, $created_after, $valid, $usable, $advocate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReferrals'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $code Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only referrals where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only referrals where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  string $advocate Filter results by match with a profile id specified in the referral&#39;s AdvocateProfileIntegrationId field (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getReferralsRequest($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null, $code = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $advocate = null)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getReferrals'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling getReferrals'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}/referrals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($code !== null) {
            $queryParams['code'] = ObjectSerializer::toQueryValue($code);
        }
        // query params
        if ($created_before !== null) {
            $queryParams['createdBefore'] = ObjectSerializer::toQueryValue($created_before);
        }
        // query params
        if ($created_after !== null) {
            $queryParams['createdAfter'] = ObjectSerializer::toQueryValue($created_after);
        }
        // query params
        if ($valid !== null) {
            $queryParams['valid'] = ObjectSerializer::toQueryValue($valid);
        }
        // query params
        if ($usable !== null) {
            $queryParams['usable'] = ObjectSerializer::toQueryValue($usable);
        }
        // query params
        if ($advocate !== null) {
            $queryParams['advocate'] = ObjectSerializer::toQueryValue($advocate);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getReferralsWithoutTotalCount
     *
     * List Referrals
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $code Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only referrals where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only referrals where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  string $advocate Filter results by match with a profile id specified in the referral&#39;s AdvocateProfileIntegrationId field (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse2007
     */
    public function getReferralsWithoutTotalCount($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null, $code = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $advocate = null)
    {
        list($response) = $this->getReferralsWithoutTotalCountWithHttpInfo($application_id, $campaign_id, $page_size, $skip, $sort, $code, $created_before, $created_after, $valid, $usable, $advocate);
        return $response;
    }

    /**
     * Operation getReferralsWithoutTotalCountWithHttpInfo
     *
     * List Referrals
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $code Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only referrals where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only referrals where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  string $advocate Filter results by match with a profile id specified in the referral&#39;s AdvocateProfileIntegrationId field (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse2007, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReferralsWithoutTotalCountWithHttpInfo($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null, $code = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $advocate = null)
    {
        $request = $this->getReferralsWithoutTotalCountRequest($application_id, $campaign_id, $page_size, $skip, $sort, $code, $created_before, $created_after, $valid, $usable, $advocate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse2007' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse2007', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse2007';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse2007',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReferralsWithoutTotalCountAsync
     *
     * List Referrals
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $code Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only referrals where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only referrals where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  string $advocate Filter results by match with a profile id specified in the referral&#39;s AdvocateProfileIntegrationId field (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReferralsWithoutTotalCountAsync($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null, $code = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $advocate = null)
    {
        return $this->getReferralsWithoutTotalCountAsyncWithHttpInfo($application_id, $campaign_id, $page_size, $skip, $sort, $code, $created_before, $created_after, $valid, $usable, $advocate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReferralsWithoutTotalCountAsyncWithHttpInfo
     *
     * List Referrals
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $code Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only referrals where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only referrals where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  string $advocate Filter results by match with a profile id specified in the referral&#39;s AdvocateProfileIntegrationId field (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReferralsWithoutTotalCountAsyncWithHttpInfo($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null, $code = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $advocate = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse2007';
        $request = $this->getReferralsWithoutTotalCountRequest($application_id, $campaign_id, $page_size, $skip, $sort, $code, $created_before, $created_after, $valid, $usable, $advocate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReferralsWithoutTotalCount'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $code Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only referrals where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only referrals where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  string $advocate Filter results by match with a profile id specified in the referral&#39;s AdvocateProfileIntegrationId field (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getReferralsWithoutTotalCountRequest($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null, $code = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $advocate = null)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getReferralsWithoutTotalCount'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling getReferralsWithoutTotalCount'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}/referrals/no_total';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($code !== null) {
            $queryParams['code'] = ObjectSerializer::toQueryValue($code);
        }
        // query params
        if ($created_before !== null) {
            $queryParams['createdBefore'] = ObjectSerializer::toQueryValue($created_before);
        }
        // query params
        if ($created_after !== null) {
            $queryParams['createdAfter'] = ObjectSerializer::toQueryValue($created_after);
        }
        // query params
        if ($valid !== null) {
            $queryParams['valid'] = ObjectSerializer::toQueryValue($valid);
        }
        // query params
        if ($usable !== null) {
            $queryParams['usable'] = ObjectSerializer::toQueryValue($usable);
        }
        // query params
        if ($advocate !== null) {
            $queryParams['advocate'] = ObjectSerializer::toQueryValue($advocate);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRole
     *
     * Get information for the specified role.
     *
     * @param  int $role_id role_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\Role
     */
    public function getRole($role_id)
    {
        list($response) = $this->getRoleWithHttpInfo($role_id);
        return $response;
    }

    /**
     * Operation getRoleWithHttpInfo
     *
     * Get information for the specified role.
     *
     * @param  int $role_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\Role, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoleWithHttpInfo($role_id)
    {
        $request = $this->getRoleRequest($role_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\Role' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\Role', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\Role';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\Role',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRoleAsync
     *
     * Get information for the specified role.
     *
     * @param  int $role_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoleAsync($role_id)
    {
        return $this->getRoleAsyncWithHttpInfo($role_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoleAsyncWithHttpInfo
     *
     * Get information for the specified role.
     *
     * @param  int $role_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoleAsyncWithHttpInfo($role_id)
    {
        $returnType = '\TalonOne\Client\Model\Role';
        $request = $this->getRoleRequest($role_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRole'
     *
     * @param  int $role_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRoleRequest($role_id)
    {
        // verify the required parameter 'role_id' is set
        if ($role_id === null || (is_array($role_id) && count($role_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $role_id when calling getRole'
            );
        }

        $resourcePath = '/v1/roles/{roleId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($role_id !== null) {
            $resourcePath = str_replace(
                '{' . 'roleId' . '}',
                ObjectSerializer::toPathValue($role_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRuleset
     *
     * Get a Ruleset
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  int $ruleset_id ruleset_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\Ruleset
     */
    public function getRuleset($application_id, $campaign_id, $ruleset_id)
    {
        list($response) = $this->getRulesetWithHttpInfo($application_id, $campaign_id, $ruleset_id);
        return $response;
    }

    /**
     * Operation getRulesetWithHttpInfo
     *
     * Get a Ruleset
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $ruleset_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\Ruleset, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRulesetWithHttpInfo($application_id, $campaign_id, $ruleset_id)
    {
        $request = $this->getRulesetRequest($application_id, $campaign_id, $ruleset_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\Ruleset' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\Ruleset', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\Ruleset';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\Ruleset',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRulesetAsync
     *
     * Get a Ruleset
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $ruleset_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRulesetAsync($application_id, $campaign_id, $ruleset_id)
    {
        return $this->getRulesetAsyncWithHttpInfo($application_id, $campaign_id, $ruleset_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRulesetAsyncWithHttpInfo
     *
     * Get a Ruleset
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $ruleset_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRulesetAsyncWithHttpInfo($application_id, $campaign_id, $ruleset_id)
    {
        $returnType = '\TalonOne\Client\Model\Ruleset';
        $request = $this->getRulesetRequest($application_id, $campaign_id, $ruleset_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRuleset'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $ruleset_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRulesetRequest($application_id, $campaign_id, $ruleset_id)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getRuleset'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling getRuleset'
            );
        }
        // verify the required parameter 'ruleset_id' is set
        if ($ruleset_id === null || (is_array($ruleset_id) && count($ruleset_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ruleset_id when calling getRuleset'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets/{rulesetId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }
        // path params
        if ($ruleset_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rulesetId' . '}',
                ObjectSerializer::toPathValue($ruleset_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRulesets
     *
     * List Campaign Rulesets
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse2004
     */
    public function getRulesets($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null)
    {
        list($response) = $this->getRulesetsWithHttpInfo($application_id, $campaign_id, $page_size, $skip, $sort);
        return $response;
    }

    /**
     * Operation getRulesetsWithHttpInfo
     *
     * List Campaign Rulesets
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse2004, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRulesetsWithHttpInfo($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null)
    {
        $request = $this->getRulesetsRequest($application_id, $campaign_id, $page_size, $skip, $sort);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse2004' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse2004', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse2004';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse2004',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRulesetsAsync
     *
     * List Campaign Rulesets
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRulesetsAsync($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null)
    {
        return $this->getRulesetsAsyncWithHttpInfo($application_id, $campaign_id, $page_size, $skip, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRulesetsAsyncWithHttpInfo
     *
     * List Campaign Rulesets
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRulesetsAsyncWithHttpInfo($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse2004';
        $request = $this->getRulesetsRequest($application_id, $campaign_id, $page_size, $skip, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRulesets'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRulesetsRequest($application_id, $campaign_id, $page_size = null, $skip = null, $sort = null)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getRulesets'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling getRulesets'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUser
     *
     * Get a single User
     *
     * @param  int $user_id user_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\User
     */
    public function getUser($user_id)
    {
        list($response) = $this->getUserWithHttpInfo($user_id);
        return $response;
    }

    /**
     * Operation getUserWithHttpInfo
     *
     * Get a single User
     *
     * @param  int $user_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserWithHttpInfo($user_id)
    {
        $request = $this->getUserRequest($user_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\User' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\User', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\User';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUserAsync
     *
     * Get a single User
     *
     * @param  int $user_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAsync($user_id)
    {
        return $this->getUserAsyncWithHttpInfo($user_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserAsyncWithHttpInfo
     *
     * Get a single User
     *
     * @param  int $user_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAsyncWithHttpInfo($user_id)
    {
        $returnType = '\TalonOne\Client\Model\User';
        $request = $this->getUserRequest($user_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUser'
     *
     * @param  int $user_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getUserRequest($user_id)
    {
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling getUser'
            );
        }

        $resourcePath = '/v1/users/{userId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUsers
     *
     * List Users in your account
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20026
     */
    public function getUsers($page_size = null, $skip = null, $sort = null)
    {
        list($response) = $this->getUsersWithHttpInfo($page_size, $skip, $sort);
        return $response;
    }

    /**
     * Operation getUsersWithHttpInfo
     *
     * List Users in your account
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20026, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUsersWithHttpInfo($page_size = null, $skip = null, $sort = null)
    {
        $request = $this->getUsersRequest($page_size, $skip, $sort);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20026' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20026', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20026';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20026',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUsersAsync
     *
     * List Users in your account
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUsersAsync($page_size = null, $skip = null, $sort = null)
    {
        return $this->getUsersAsyncWithHttpInfo($page_size, $skip, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUsersAsyncWithHttpInfo
     *
     * List Users in your account
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUsersAsyncWithHttpInfo($page_size = null, $skip = null, $sort = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20026';
        $request = $this->getUsersRequest($page_size, $skip, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUsers'
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getUsersRequest($page_size = null, $skip = null, $sort = null)
    {

        $resourcePath = '/v1/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebhook
     *
     * Get Webhook
     *
     * @param  int $webhook_id webhook_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\Webhook
     */
    public function getWebhook($webhook_id)
    {
        list($response) = $this->getWebhookWithHttpInfo($webhook_id);
        return $response;
    }

    /**
     * Operation getWebhookWithHttpInfo
     *
     * Get Webhook
     *
     * @param  int $webhook_id (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\Webhook, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebhookWithHttpInfo($webhook_id)
    {
        $request = $this->getWebhookRequest($webhook_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\Webhook' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\Webhook', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\Webhook';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\Webhook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebhookAsync
     *
     * Get Webhook
     *
     * @param  int $webhook_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookAsync($webhook_id)
    {
        return $this->getWebhookAsyncWithHttpInfo($webhook_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebhookAsyncWithHttpInfo
     *
     * Get Webhook
     *
     * @param  int $webhook_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookAsyncWithHttpInfo($webhook_id)
    {
        $returnType = '\TalonOne\Client\Model\Webhook';
        $request = $this->getWebhookRequest($webhook_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebhook'
     *
     * @param  int $webhook_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWebhookRequest($webhook_id)
    {
        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling getWebhook'
            );
        }

        $resourcePath = '/v1/webhooks/{webhookId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhookId' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebhookActivationLogs
     *
     * List Webhook activation Log Entries
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $integration_request_uuid Filter results by integration request UUID. (optional)
     * @param  float $webhook_id Filter results by Webhook. (optional)
     * @param  float $application_id application_id (optional)
     * @param  float $campaign_id Filter results by campaign. (optional)
     * @param  \DateTime $created_before Only return events created before this date. (optional)
     * @param  \DateTime $created_after Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20023
     */
    public function getWebhookActivationLogs($page_size = null, $skip = null, $sort = null, $integration_request_uuid = null, $webhook_id = null, $application_id = null, $campaign_id = null, $created_before = null, $created_after = null)
    {
        list($response) = $this->getWebhookActivationLogsWithHttpInfo($page_size, $skip, $sort, $integration_request_uuid, $webhook_id, $application_id, $campaign_id, $created_before, $created_after);
        return $response;
    }

    /**
     * Operation getWebhookActivationLogsWithHttpInfo
     *
     * List Webhook activation Log Entries
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $integration_request_uuid Filter results by integration request UUID. (optional)
     * @param  float $webhook_id Filter results by Webhook. (optional)
     * @param  float $application_id (optional)
     * @param  float $campaign_id Filter results by campaign. (optional)
     * @param  \DateTime $created_before Only return events created before this date. (optional)
     * @param  \DateTime $created_after Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20023, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebhookActivationLogsWithHttpInfo($page_size = null, $skip = null, $sort = null, $integration_request_uuid = null, $webhook_id = null, $application_id = null, $campaign_id = null, $created_before = null, $created_after = null)
    {
        $request = $this->getWebhookActivationLogsRequest($page_size, $skip, $sort, $integration_request_uuid, $webhook_id, $application_id, $campaign_id, $created_before, $created_after);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20023' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20023', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20023';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20023',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebhookActivationLogsAsync
     *
     * List Webhook activation Log Entries
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $integration_request_uuid Filter results by integration request UUID. (optional)
     * @param  float $webhook_id Filter results by Webhook. (optional)
     * @param  float $application_id (optional)
     * @param  float $campaign_id Filter results by campaign. (optional)
     * @param  \DateTime $created_before Only return events created before this date. (optional)
     * @param  \DateTime $created_after Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookActivationLogsAsync($page_size = null, $skip = null, $sort = null, $integration_request_uuid = null, $webhook_id = null, $application_id = null, $campaign_id = null, $created_before = null, $created_after = null)
    {
        return $this->getWebhookActivationLogsAsyncWithHttpInfo($page_size, $skip, $sort, $integration_request_uuid, $webhook_id, $application_id, $campaign_id, $created_before, $created_after)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebhookActivationLogsAsyncWithHttpInfo
     *
     * List Webhook activation Log Entries
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $integration_request_uuid Filter results by integration request UUID. (optional)
     * @param  float $webhook_id Filter results by Webhook. (optional)
     * @param  float $application_id (optional)
     * @param  float $campaign_id Filter results by campaign. (optional)
     * @param  \DateTime $created_before Only return events created before this date. (optional)
     * @param  \DateTime $created_after Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookActivationLogsAsyncWithHttpInfo($page_size = null, $skip = null, $sort = null, $integration_request_uuid = null, $webhook_id = null, $application_id = null, $campaign_id = null, $created_before = null, $created_after = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20023';
        $request = $this->getWebhookActivationLogsRequest($page_size, $skip, $sort, $integration_request_uuid, $webhook_id, $application_id, $campaign_id, $created_before, $created_after);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebhookActivationLogs'
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $integration_request_uuid Filter results by integration request UUID. (optional)
     * @param  float $webhook_id Filter results by Webhook. (optional)
     * @param  float $application_id (optional)
     * @param  float $campaign_id Filter results by campaign. (optional)
     * @param  \DateTime $created_before Only return events created before this date. (optional)
     * @param  \DateTime $created_after Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWebhookActivationLogsRequest($page_size = null, $skip = null, $sort = null, $integration_request_uuid = null, $webhook_id = null, $application_id = null, $campaign_id = null, $created_before = null, $created_after = null)
    {

        $resourcePath = '/v1/webhook_activation_logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($integration_request_uuid !== null) {
            $queryParams['integrationRequestUuid'] = ObjectSerializer::toQueryValue($integration_request_uuid);
        }
        // query params
        if ($webhook_id !== null) {
            $queryParams['webhookId'] = ObjectSerializer::toQueryValue($webhook_id);
        }
        // query params
        if ($application_id !== null) {
            $queryParams['applicationId'] = ObjectSerializer::toQueryValue($application_id);
        }
        // query params
        if ($campaign_id !== null) {
            $queryParams['campaignId'] = ObjectSerializer::toQueryValue($campaign_id);
        }
        // query params
        if ($created_before !== null) {
            $queryParams['createdBefore'] = ObjectSerializer::toQueryValue($created_before);
        }
        // query params
        if ($created_after !== null) {
            $queryParams['createdAfter'] = ObjectSerializer::toQueryValue($created_after);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebhookLogs
     *
     * List Webhook Log Entries
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $status Filter results by HTTP status codes. (optional)
     * @param  float $webhook_id Filter results by Webhook. (optional)
     * @param  float $application_id application_id (optional)
     * @param  float $campaign_id Filter results by campaign. (optional)
     * @param  string $request_uuid Filter results by request UUID. (optional)
     * @param  \DateTime $created_before Filter results where request and response times to return entries before parameter value, expected to be an RFC3339 timestamp string. (optional)
     * @param  \DateTime $created_after Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20024
     */
    public function getWebhookLogs($page_size = null, $skip = null, $sort = null, $status = null, $webhook_id = null, $application_id = null, $campaign_id = null, $request_uuid = null, $created_before = null, $created_after = null)
    {
        list($response) = $this->getWebhookLogsWithHttpInfo($page_size, $skip, $sort, $status, $webhook_id, $application_id, $campaign_id, $request_uuid, $created_before, $created_after);
        return $response;
    }

    /**
     * Operation getWebhookLogsWithHttpInfo
     *
     * List Webhook Log Entries
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $status Filter results by HTTP status codes. (optional)
     * @param  float $webhook_id Filter results by Webhook. (optional)
     * @param  float $application_id (optional)
     * @param  float $campaign_id Filter results by campaign. (optional)
     * @param  string $request_uuid Filter results by request UUID. (optional)
     * @param  \DateTime $created_before Filter results where request and response times to return entries before parameter value, expected to be an RFC3339 timestamp string. (optional)
     * @param  \DateTime $created_after Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20024, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebhookLogsWithHttpInfo($page_size = null, $skip = null, $sort = null, $status = null, $webhook_id = null, $application_id = null, $campaign_id = null, $request_uuid = null, $created_before = null, $created_after = null)
    {
        $request = $this->getWebhookLogsRequest($page_size, $skip, $sort, $status, $webhook_id, $application_id, $campaign_id, $request_uuid, $created_before, $created_after);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20024' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20024', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20024';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20024',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebhookLogsAsync
     *
     * List Webhook Log Entries
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $status Filter results by HTTP status codes. (optional)
     * @param  float $webhook_id Filter results by Webhook. (optional)
     * @param  float $application_id (optional)
     * @param  float $campaign_id Filter results by campaign. (optional)
     * @param  string $request_uuid Filter results by request UUID. (optional)
     * @param  \DateTime $created_before Filter results where request and response times to return entries before parameter value, expected to be an RFC3339 timestamp string. (optional)
     * @param  \DateTime $created_after Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookLogsAsync($page_size = null, $skip = null, $sort = null, $status = null, $webhook_id = null, $application_id = null, $campaign_id = null, $request_uuid = null, $created_before = null, $created_after = null)
    {
        return $this->getWebhookLogsAsyncWithHttpInfo($page_size, $skip, $sort, $status, $webhook_id, $application_id, $campaign_id, $request_uuid, $created_before, $created_after)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebhookLogsAsyncWithHttpInfo
     *
     * List Webhook Log Entries
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $status Filter results by HTTP status codes. (optional)
     * @param  float $webhook_id Filter results by Webhook. (optional)
     * @param  float $application_id (optional)
     * @param  float $campaign_id Filter results by campaign. (optional)
     * @param  string $request_uuid Filter results by request UUID. (optional)
     * @param  \DateTime $created_before Filter results where request and response times to return entries before parameter value, expected to be an RFC3339 timestamp string. (optional)
     * @param  \DateTime $created_after Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookLogsAsyncWithHttpInfo($page_size = null, $skip = null, $sort = null, $status = null, $webhook_id = null, $application_id = null, $campaign_id = null, $request_uuid = null, $created_before = null, $created_after = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20024';
        $request = $this->getWebhookLogsRequest($page_size, $skip, $sort, $status, $webhook_id, $application_id, $campaign_id, $request_uuid, $created_before, $created_after);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebhookLogs'
     *
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $status Filter results by HTTP status codes. (optional)
     * @param  float $webhook_id Filter results by Webhook. (optional)
     * @param  float $application_id (optional)
     * @param  float $campaign_id Filter results by campaign. (optional)
     * @param  string $request_uuid Filter results by request UUID. (optional)
     * @param  \DateTime $created_before Filter results where request and response times to return entries before parameter value, expected to be an RFC3339 timestamp string. (optional)
     * @param  \DateTime $created_after Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWebhookLogsRequest($page_size = null, $skip = null, $sort = null, $status = null, $webhook_id = null, $application_id = null, $campaign_id = null, $request_uuid = null, $created_before = null, $created_after = null)
    {

        $resourcePath = '/v1/webhook_logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($webhook_id !== null) {
            $queryParams['webhookId'] = ObjectSerializer::toQueryValue($webhook_id);
        }
        // query params
        if ($application_id !== null) {
            $queryParams['applicationId'] = ObjectSerializer::toQueryValue($application_id);
        }
        // query params
        if ($campaign_id !== null) {
            $queryParams['campaignId'] = ObjectSerializer::toQueryValue($campaign_id);
        }
        // query params
        if ($request_uuid !== null) {
            $queryParams['requestUuid'] = ObjectSerializer::toQueryValue($request_uuid);
        }
        // query params
        if ($created_before !== null) {
            $queryParams['createdBefore'] = ObjectSerializer::toQueryValue($created_before);
        }
        // query params
        if ($created_after !== null) {
            $queryParams['createdAfter'] = ObjectSerializer::toQueryValue($created_after);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebhooks
     *
     * List Webhooks
     *
     * @param  string $application_ids Filter by one or more application ids separated by comma (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse20022
     */
    public function getWebhooks($application_ids = null, $sort = null, $page_size = null, $skip = null)
    {
        list($response) = $this->getWebhooksWithHttpInfo($application_ids, $sort, $page_size, $skip);
        return $response;
    }

    /**
     * Operation getWebhooksWithHttpInfo
     *
     * List Webhooks
     *
     * @param  string $application_ids Filter by one or more application ids separated by comma (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse20022, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebhooksWithHttpInfo($application_ids = null, $sort = null, $page_size = null, $skip = null)
    {
        $request = $this->getWebhooksRequest($application_ids, $sort, $page_size, $skip);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse20022' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse20022', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse20022';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse20022',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebhooksAsync
     *
     * List Webhooks
     *
     * @param  string $application_ids Filter by one or more application ids separated by comma (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhooksAsync($application_ids = null, $sort = null, $page_size = null, $skip = null)
    {
        return $this->getWebhooksAsyncWithHttpInfo($application_ids, $sort, $page_size, $skip)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebhooksAsyncWithHttpInfo
     *
     * List Webhooks
     *
     * @param  string $application_ids Filter by one or more application ids separated by comma (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhooksAsyncWithHttpInfo($application_ids = null, $sort = null, $page_size = null, $skip = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse20022';
        $request = $this->getWebhooksRequest($application_ids, $sort, $page_size, $skip);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebhooks'
     *
     * @param  string $application_ids Filter by one or more application ids separated by comma (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWebhooksRequest($application_ids = null, $sort = null, $page_size = null, $skip = null)
    {

        $resourcePath = '/v1/webhooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($application_ids !== null) {
            $queryParams['applicationIds'] = ObjectSerializer::toQueryValue($application_ids);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeLoyaltyPoints
     *
     * Deduct points in a certain loyalty program for the specified customer
     *
     * @param  string $program_id program_id (required)
     * @param  string $integration_id integration_id (required)
     * @param  \TalonOne\Client\Model\LoyaltyPoints $body body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function removeLoyaltyPoints($program_id, $integration_id, $body)
    {
        $this->removeLoyaltyPointsWithHttpInfo($program_id, $integration_id, $body);
    }

    /**
     * Operation removeLoyaltyPointsWithHttpInfo
     *
     * Deduct points in a certain loyalty program for the specified customer
     *
     * @param  string $program_id (required)
     * @param  string $integration_id (required)
     * @param  \TalonOne\Client\Model\LoyaltyPoints $body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeLoyaltyPointsWithHttpInfo($program_id, $integration_id, $body)
    {
        $request = $this->removeLoyaltyPointsRequest($program_id, $integration_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation removeLoyaltyPointsAsync
     *
     * Deduct points in a certain loyalty program for the specified customer
     *
     * @param  string $program_id (required)
     * @param  string $integration_id (required)
     * @param  \TalonOne\Client\Model\LoyaltyPoints $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeLoyaltyPointsAsync($program_id, $integration_id, $body)
    {
        return $this->removeLoyaltyPointsAsyncWithHttpInfo($program_id, $integration_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeLoyaltyPointsAsyncWithHttpInfo
     *
     * Deduct points in a certain loyalty program for the specified customer
     *
     * @param  string $program_id (required)
     * @param  string $integration_id (required)
     * @param  \TalonOne\Client\Model\LoyaltyPoints $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeLoyaltyPointsAsyncWithHttpInfo($program_id, $integration_id, $body)
    {
        $returnType = '';
        $request = $this->removeLoyaltyPointsRequest($program_id, $integration_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeLoyaltyPoints'
     *
     * @param  string $program_id (required)
     * @param  string $integration_id (required)
     * @param  \TalonOne\Client\Model\LoyaltyPoints $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function removeLoyaltyPointsRequest($program_id, $integration_id, $body)
    {
        // verify the required parameter 'program_id' is set
        if ($program_id === null || (is_array($program_id) && count($program_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $program_id when calling removeLoyaltyPoints'
            );
        }
        // verify the required parameter 'integration_id' is set
        if ($integration_id === null || (is_array($integration_id) && count($integration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $integration_id when calling removeLoyaltyPoints'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling removeLoyaltyPoints'
            );
        }

        $resourcePath = '/v1/loyalty_programs/{programID}/profile/{integrationID}/deduct_points';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($program_id !== null) {
            $resourcePath = str_replace(
                '{' . 'programID' . '}',
                ObjectSerializer::toPathValue($program_id),
                $resourcePath
            );
        }
        // path params
        if ($integration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'integrationID' . '}',
                ObjectSerializer::toPathValue($integration_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resetPassword
     *
     * Reset password
     *
     * @param  \TalonOne\Client\Model\NewPassword $body body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\NewPassword
     */
    public function resetPassword($body)
    {
        list($response) = $this->resetPasswordWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation resetPasswordWithHttpInfo
     *
     * Reset password
     *
     * @param  \TalonOne\Client\Model\NewPassword $body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\NewPassword, HTTP status code, HTTP response headers (array of strings)
     */
    public function resetPasswordWithHttpInfo($body)
    {
        $request = $this->resetPasswordRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 204:
                    if ('\TalonOne\Client\Model\NewPassword' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\NewPassword', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\NewPassword';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\NewPassword',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation resetPasswordAsync
     *
     * Reset password
     *
     * @param  \TalonOne\Client\Model\NewPassword $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetPasswordAsync($body)
    {
        return $this->resetPasswordAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resetPasswordAsyncWithHttpInfo
     *
     * Reset password
     *
     * @param  \TalonOne\Client\Model\NewPassword $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetPasswordAsyncWithHttpInfo($body)
    {
        $returnType = '\TalonOne\Client\Model\NewPassword';
        $request = $this->resetPasswordRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resetPassword'
     *
     * @param  \TalonOne\Client\Model\NewPassword $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function resetPasswordRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling resetPassword'
            );
        }

        $resourcePath = '/v1/reset_password';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchCouponsAdvanced
     *
     * Get a list of the coupons that match the given attributes
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  object $body body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse2001
     */
    public function searchCouponsAdvanced($application_id, $campaign_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false, $batch_id = null)
    {
        list($response) = $this->searchCouponsAdvancedWithHttpInfo($application_id, $campaign_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $exact_match, $batch_id);
        return $response;
    }

    /**
     * Operation searchCouponsAdvancedWithHttpInfo
     *
     * Get a list of the coupons that match the given attributes
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  object $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchCouponsAdvancedWithHttpInfo($application_id, $campaign_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false, $batch_id = null)
    {
        $request = $this->searchCouponsAdvancedRequest($application_id, $campaign_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $exact_match, $batch_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse2001' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse2001', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse2001';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse2001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchCouponsAdvancedAsync
     *
     * Get a list of the coupons that match the given attributes
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  object $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchCouponsAdvancedAsync($application_id, $campaign_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false, $batch_id = null)
    {
        return $this->searchCouponsAdvancedAsyncWithHttpInfo($application_id, $campaign_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $exact_match, $batch_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchCouponsAdvancedAsyncWithHttpInfo
     *
     * Get a list of the coupons that match the given attributes
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  object $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchCouponsAdvancedAsyncWithHttpInfo($application_id, $campaign_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false, $batch_id = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse2001';
        $request = $this->searchCouponsAdvancedRequest($application_id, $campaign_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $exact_match, $batch_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchCouponsAdvanced'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  object $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchCouponsAdvancedRequest($application_id, $campaign_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false, $batch_id = null)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling searchCouponsAdvanced'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling searchCouponsAdvanced'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling searchCouponsAdvanced'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons_search_advanced';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($value !== null) {
            $queryParams['value'] = ObjectSerializer::toQueryValue($value);
        }
        // query params
        if ($created_before !== null) {
            $queryParams['createdBefore'] = ObjectSerializer::toQueryValue($created_before);
        }
        // query params
        if ($created_after !== null) {
            $queryParams['createdAfter'] = ObjectSerializer::toQueryValue($created_after);
        }
        // query params
        if ($valid !== null) {
            $queryParams['valid'] = ObjectSerializer::toQueryValue($valid);
        }
        // query params
        if ($usable !== null) {
            $queryParams['usable'] = ObjectSerializer::toQueryValue($usable);
        }
        // query params
        if ($referral_id !== null) {
            $queryParams['referralId'] = ObjectSerializer::toQueryValue($referral_id);
        }
        // query params
        if ($recipient_integration_id !== null) {
            $queryParams['recipientIntegrationId'] = ObjectSerializer::toQueryValue($recipient_integration_id);
        }
        // query params
        if ($exact_match !== null) {
            $queryParams['exactMatch'] = ObjectSerializer::toQueryValue($exact_match);
        }
        // query params
        if ($batch_id !== null) {
            $queryParams['batchId'] = ObjectSerializer::toQueryValue($batch_id);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchCouponsAdvancedApplicationWide
     *
     * Get a list of the coupons that match the given attributes in all active campaigns of an application
     *
     * @param  int $application_id application_id (required)
     * @param  object $body body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse2001
     */
    public function searchCouponsAdvancedApplicationWide($application_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $batch_id = null, $exact_match = false, $campaign_state = null)
    {
        list($response) = $this->searchCouponsAdvancedApplicationWideWithHttpInfo($application_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $batch_id, $exact_match, $campaign_state);
        return $response;
    }

    /**
     * Operation searchCouponsAdvancedApplicationWideWithHttpInfo
     *
     * Get a list of the coupons that match the given attributes in all active campaigns of an application
     *
     * @param  int $application_id (required)
     * @param  object $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchCouponsAdvancedApplicationWideWithHttpInfo($application_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $batch_id = null, $exact_match = false, $campaign_state = null)
    {
        $request = $this->searchCouponsAdvancedApplicationWideRequest($application_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $batch_id, $exact_match, $campaign_state);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse2001' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse2001', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse2001';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse2001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchCouponsAdvancedApplicationWideAsync
     *
     * Get a list of the coupons that match the given attributes in all active campaigns of an application
     *
     * @param  int $application_id (required)
     * @param  object $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchCouponsAdvancedApplicationWideAsync($application_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $batch_id = null, $exact_match = false, $campaign_state = null)
    {
        return $this->searchCouponsAdvancedApplicationWideAsyncWithHttpInfo($application_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $batch_id, $exact_match, $campaign_state)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchCouponsAdvancedApplicationWideAsyncWithHttpInfo
     *
     * Get a list of the coupons that match the given attributes in all active campaigns of an application
     *
     * @param  int $application_id (required)
     * @param  object $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchCouponsAdvancedApplicationWideAsyncWithHttpInfo($application_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $batch_id = null, $exact_match = false, $campaign_state = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse2001';
        $request = $this->searchCouponsAdvancedApplicationWideRequest($application_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $batch_id, $exact_match, $campaign_state);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchCouponsAdvancedApplicationWide'
     *
     * @param  int $application_id (required)
     * @param  object $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchCouponsAdvancedApplicationWideRequest($application_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $batch_id = null, $exact_match = false, $campaign_state = null)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling searchCouponsAdvancedApplicationWide'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling searchCouponsAdvancedApplicationWide'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/coupons_search_advanced';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($value !== null) {
            $queryParams['value'] = ObjectSerializer::toQueryValue($value);
        }
        // query params
        if ($created_before !== null) {
            $queryParams['createdBefore'] = ObjectSerializer::toQueryValue($created_before);
        }
        // query params
        if ($created_after !== null) {
            $queryParams['createdAfter'] = ObjectSerializer::toQueryValue($created_after);
        }
        // query params
        if ($valid !== null) {
            $queryParams['valid'] = ObjectSerializer::toQueryValue($valid);
        }
        // query params
        if ($usable !== null) {
            $queryParams['usable'] = ObjectSerializer::toQueryValue($usable);
        }
        // query params
        if ($referral_id !== null) {
            $queryParams['referralId'] = ObjectSerializer::toQueryValue($referral_id);
        }
        // query params
        if ($recipient_integration_id !== null) {
            $queryParams['recipientIntegrationId'] = ObjectSerializer::toQueryValue($recipient_integration_id);
        }
        // query params
        if ($batch_id !== null) {
            $queryParams['batchId'] = ObjectSerializer::toQueryValue($batch_id);
        }
        // query params
        if ($exact_match !== null) {
            $queryParams['exactMatch'] = ObjectSerializer::toQueryValue($exact_match);
        }
        // query params
        if ($campaign_state !== null) {
            $queryParams['campaignState'] = ObjectSerializer::toQueryValue($campaign_state);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchCouponsAdvancedApplicationWideWithoutTotalCount
     *
     * Get a list of the coupons that match the given attributes in all active campaigns of an application
     *
     * @param  int $application_id application_id (required)
     * @param  object $body body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse2005
     */
    public function searchCouponsAdvancedApplicationWideWithoutTotalCount($application_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $batch_id = null, $exact_match = false, $campaign_state = null)
    {
        list($response) = $this->searchCouponsAdvancedApplicationWideWithoutTotalCountWithHttpInfo($application_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $batch_id, $exact_match, $campaign_state);
        return $response;
    }

    /**
     * Operation searchCouponsAdvancedApplicationWideWithoutTotalCountWithHttpInfo
     *
     * Get a list of the coupons that match the given attributes in all active campaigns of an application
     *
     * @param  int $application_id (required)
     * @param  object $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse2005, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchCouponsAdvancedApplicationWideWithoutTotalCountWithHttpInfo($application_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $batch_id = null, $exact_match = false, $campaign_state = null)
    {
        $request = $this->searchCouponsAdvancedApplicationWideWithoutTotalCountRequest($application_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $batch_id, $exact_match, $campaign_state);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse2005' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse2005', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse2005';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse2005',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchCouponsAdvancedApplicationWideWithoutTotalCountAsync
     *
     * Get a list of the coupons that match the given attributes in all active campaigns of an application
     *
     * @param  int $application_id (required)
     * @param  object $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchCouponsAdvancedApplicationWideWithoutTotalCountAsync($application_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $batch_id = null, $exact_match = false, $campaign_state = null)
    {
        return $this->searchCouponsAdvancedApplicationWideWithoutTotalCountAsyncWithHttpInfo($application_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $batch_id, $exact_match, $campaign_state)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchCouponsAdvancedApplicationWideWithoutTotalCountAsyncWithHttpInfo
     *
     * Get a list of the coupons that match the given attributes in all active campaigns of an application
     *
     * @param  int $application_id (required)
     * @param  object $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchCouponsAdvancedApplicationWideWithoutTotalCountAsyncWithHttpInfo($application_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $batch_id = null, $exact_match = false, $campaign_state = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse2005';
        $request = $this->searchCouponsAdvancedApplicationWideWithoutTotalCountRequest($application_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $batch_id, $exact_match, $campaign_state);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchCouponsAdvancedApplicationWideWithoutTotalCount'
     *
     * @param  int $application_id (required)
     * @param  object $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $campaign_state Filter results by the state of the campaign. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchCouponsAdvancedApplicationWideWithoutTotalCountRequest($application_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $batch_id = null, $exact_match = false, $campaign_state = null)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling searchCouponsAdvancedApplicationWideWithoutTotalCount'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling searchCouponsAdvancedApplicationWideWithoutTotalCount'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/coupons_search_advanced/no_total';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($value !== null) {
            $queryParams['value'] = ObjectSerializer::toQueryValue($value);
        }
        // query params
        if ($created_before !== null) {
            $queryParams['createdBefore'] = ObjectSerializer::toQueryValue($created_before);
        }
        // query params
        if ($created_after !== null) {
            $queryParams['createdAfter'] = ObjectSerializer::toQueryValue($created_after);
        }
        // query params
        if ($valid !== null) {
            $queryParams['valid'] = ObjectSerializer::toQueryValue($valid);
        }
        // query params
        if ($usable !== null) {
            $queryParams['usable'] = ObjectSerializer::toQueryValue($usable);
        }
        // query params
        if ($referral_id !== null) {
            $queryParams['referralId'] = ObjectSerializer::toQueryValue($referral_id);
        }
        // query params
        if ($recipient_integration_id !== null) {
            $queryParams['recipientIntegrationId'] = ObjectSerializer::toQueryValue($recipient_integration_id);
        }
        // query params
        if ($batch_id !== null) {
            $queryParams['batchId'] = ObjectSerializer::toQueryValue($batch_id);
        }
        // query params
        if ($exact_match !== null) {
            $queryParams['exactMatch'] = ObjectSerializer::toQueryValue($exact_match);
        }
        // query params
        if ($campaign_state !== null) {
            $queryParams['campaignState'] = ObjectSerializer::toQueryValue($campaign_state);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchCouponsAdvancedWithoutTotalCount
     *
     * Get a list of the coupons that match the given attributes
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  object $body body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\InlineResponse2005
     */
    public function searchCouponsAdvancedWithoutTotalCount($application_id, $campaign_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false, $batch_id = null)
    {
        list($response) = $this->searchCouponsAdvancedWithoutTotalCountWithHttpInfo($application_id, $campaign_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $exact_match, $batch_id);
        return $response;
    }

    /**
     * Operation searchCouponsAdvancedWithoutTotalCountWithHttpInfo
     *
     * Get a list of the coupons that match the given attributes
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  object $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\InlineResponse2005, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchCouponsAdvancedWithoutTotalCountWithHttpInfo($application_id, $campaign_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false, $batch_id = null)
    {
        $request = $this->searchCouponsAdvancedWithoutTotalCountRequest($application_id, $campaign_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $exact_match, $batch_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\InlineResponse2005' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\InlineResponse2005', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\InlineResponse2005';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\InlineResponse2005',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchCouponsAdvancedWithoutTotalCountAsync
     *
     * Get a list of the coupons that match the given attributes
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  object $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchCouponsAdvancedWithoutTotalCountAsync($application_id, $campaign_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false, $batch_id = null)
    {
        return $this->searchCouponsAdvancedWithoutTotalCountAsyncWithHttpInfo($application_id, $campaign_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $exact_match, $batch_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchCouponsAdvancedWithoutTotalCountAsyncWithHttpInfo
     *
     * Get a list of the coupons that match the given attributes
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  object $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchCouponsAdvancedWithoutTotalCountAsyncWithHttpInfo($application_id, $campaign_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false, $batch_id = null)
    {
        $returnType = '\TalonOne\Client\Model\InlineResponse2005';
        $request = $this->searchCouponsAdvancedWithoutTotalCountRequest($application_id, $campaign_id, $body, $page_size, $skip, $sort, $value, $created_before, $created_after, $valid, $usable, $referral_id, $recipient_integration_id, $exact_match, $batch_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchCouponsAdvancedWithoutTotalCount'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  object $body (required)
     * @param  int $page_size The number of items to include in this response. When omitted, the maximum value of 1000 will be used. (optional)
     * @param  int $skip Skips the given number of items when paging through large result sets. (optional)
     * @param  string $sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with &#x60;-&#x60; to sort in descending order. (optional)
     * @param  string $value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters. (optional)
     * @param  \DateTime $created_before Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  \DateTime $created_after Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. (optional)
     * @param  string $valid Either \&quot;expired\&quot;, \&quot;validNow\&quot;, or \&quot;validFuture\&quot;. The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. (optional)
     * @param  string $usable Either \&quot;true\&quot; or \&quot;false\&quot;. If \&quot;true\&quot;, only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned, \&quot;false\&quot; will return only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60;. (optional)
     * @param  int $referral_id Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code. (optional)
     * @param  string $recipient_integration_id Filter results by match with a profile id specified in the coupon&#39;s RecipientIntegrationId field (optional)
     * @param  bool $exact_match Filter results to an exact case-insensitive matching against the coupon code (optional, default to false)
     * @param  string $batch_id Filter results by batches of coupons (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchCouponsAdvancedWithoutTotalCountRequest($application_id, $campaign_id, $body, $page_size = null, $skip = null, $sort = null, $value = null, $created_before = null, $created_after = null, $valid = null, $usable = null, $referral_id = null, $recipient_integration_id = null, $exact_match = false, $batch_id = null)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling searchCouponsAdvancedWithoutTotalCount'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling searchCouponsAdvancedWithoutTotalCount'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling searchCouponsAdvancedWithoutTotalCount'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons_search_advanced/no_total';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($value !== null) {
            $queryParams['value'] = ObjectSerializer::toQueryValue($value);
        }
        // query params
        if ($created_before !== null) {
            $queryParams['createdBefore'] = ObjectSerializer::toQueryValue($created_before);
        }
        // query params
        if ($created_after !== null) {
            $queryParams['createdAfter'] = ObjectSerializer::toQueryValue($created_after);
        }
        // query params
        if ($valid !== null) {
            $queryParams['valid'] = ObjectSerializer::toQueryValue($valid);
        }
        // query params
        if ($usable !== null) {
            $queryParams['usable'] = ObjectSerializer::toQueryValue($usable);
        }
        // query params
        if ($referral_id !== null) {
            $queryParams['referralId'] = ObjectSerializer::toQueryValue($referral_id);
        }
        // query params
        if ($recipient_integration_id !== null) {
            $queryParams['recipientIntegrationId'] = ObjectSerializer::toQueryValue($recipient_integration_id);
        }
        // query params
        if ($exact_match !== null) {
            $queryParams['exactMatch'] = ObjectSerializer::toQueryValue($exact_match);
        }
        // query params
        if ($batch_id !== null) {
            $queryParams['batchId'] = ObjectSerializer::toQueryValue($batch_id);
        }

        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAdditionalCost
     *
     * Update an additional cost
     *
     * @param  int $additional_cost_id additional_cost_id (required)
     * @param  \TalonOne\Client\Model\NewAdditionalCost $body body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\AccountAdditionalCost
     */
    public function updateAdditionalCost($additional_cost_id, $body)
    {
        list($response) = $this->updateAdditionalCostWithHttpInfo($additional_cost_id, $body);
        return $response;
    }

    /**
     * Operation updateAdditionalCostWithHttpInfo
     *
     * Update an additional cost
     *
     * @param  int $additional_cost_id (required)
     * @param  \TalonOne\Client\Model\NewAdditionalCost $body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\AccountAdditionalCost, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAdditionalCostWithHttpInfo($additional_cost_id, $body)
    {
        $request = $this->updateAdditionalCostRequest($additional_cost_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\AccountAdditionalCost' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\AccountAdditionalCost', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\AccountAdditionalCost';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\AccountAdditionalCost',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAdditionalCostAsync
     *
     * Update an additional cost
     *
     * @param  int $additional_cost_id (required)
     * @param  \TalonOne\Client\Model\NewAdditionalCost $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAdditionalCostAsync($additional_cost_id, $body)
    {
        return $this->updateAdditionalCostAsyncWithHttpInfo($additional_cost_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAdditionalCostAsyncWithHttpInfo
     *
     * Update an additional cost
     *
     * @param  int $additional_cost_id (required)
     * @param  \TalonOne\Client\Model\NewAdditionalCost $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAdditionalCostAsyncWithHttpInfo($additional_cost_id, $body)
    {
        $returnType = '\TalonOne\Client\Model\AccountAdditionalCost';
        $request = $this->updateAdditionalCostRequest($additional_cost_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAdditionalCost'
     *
     * @param  int $additional_cost_id (required)
     * @param  \TalonOne\Client\Model\NewAdditionalCost $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateAdditionalCostRequest($additional_cost_id, $body)
    {
        // verify the required parameter 'additional_cost_id' is set
        if ($additional_cost_id === null || (is_array($additional_cost_id) && count($additional_cost_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $additional_cost_id when calling updateAdditionalCost'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateAdditionalCost'
            );
        }

        $resourcePath = '/v1/additional_costs/{additionalCostId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($additional_cost_id !== null) {
            $resourcePath = str_replace(
                '{' . 'additionalCostId' . '}',
                ObjectSerializer::toPathValue($additional_cost_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAttribute
     *
     * Update a custom attribute
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  \TalonOne\Client\Model\NewAttribute $body body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\Attribute
     */
    public function updateAttribute($attribute_id, $body)
    {
        list($response) = $this->updateAttributeWithHttpInfo($attribute_id, $body);
        return $response;
    }

    /**
     * Operation updateAttributeWithHttpInfo
     *
     * Update a custom attribute
     *
     * @param  int $attribute_id (required)
     * @param  \TalonOne\Client\Model\NewAttribute $body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\Attribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAttributeWithHttpInfo($attribute_id, $body)
    {
        $request = $this->updateAttributeRequest($attribute_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\Attribute' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\Attribute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\Attribute';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\Attribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAttributeAsync
     *
     * Update a custom attribute
     *
     * @param  int $attribute_id (required)
     * @param  \TalonOne\Client\Model\NewAttribute $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAttributeAsync($attribute_id, $body)
    {
        return $this->updateAttributeAsyncWithHttpInfo($attribute_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAttributeAsyncWithHttpInfo
     *
     * Update a custom attribute
     *
     * @param  int $attribute_id (required)
     * @param  \TalonOne\Client\Model\NewAttribute $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAttributeAsyncWithHttpInfo($attribute_id, $body)
    {
        $returnType = '\TalonOne\Client\Model\Attribute';
        $request = $this->updateAttributeRequest($attribute_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAttribute'
     *
     * @param  int $attribute_id (required)
     * @param  \TalonOne\Client\Model\NewAttribute $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateAttributeRequest($attribute_id, $body)
    {
        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling updateAttribute'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateAttribute'
            );
        }

        $resourcePath = '/v1/attributes/{attributeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCampaign
     *
     * Update a Campaign
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  \TalonOne\Client\Model\UpdateCampaign $body body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\Campaign
     */
    public function updateCampaign($application_id, $campaign_id, $body)
    {
        list($response) = $this->updateCampaignWithHttpInfo($application_id, $campaign_id, $body);
        return $response;
    }

    /**
     * Operation updateCampaignWithHttpInfo
     *
     * Update a Campaign
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\UpdateCampaign $body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\Campaign, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCampaignWithHttpInfo($application_id, $campaign_id, $body)
    {
        $request = $this->updateCampaignRequest($application_id, $campaign_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\Campaign' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\Campaign', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\Campaign';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\Campaign',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateCampaignAsync
     *
     * Update a Campaign
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\UpdateCampaign $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCampaignAsync($application_id, $campaign_id, $body)
    {
        return $this->updateCampaignAsyncWithHttpInfo($application_id, $campaign_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCampaignAsyncWithHttpInfo
     *
     * Update a Campaign
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\UpdateCampaign $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCampaignAsyncWithHttpInfo($application_id, $campaign_id, $body)
    {
        $returnType = '\TalonOne\Client\Model\Campaign';
        $request = $this->updateCampaignRequest($application_id, $campaign_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCampaign'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\UpdateCampaign $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateCampaignRequest($application_id, $campaign_id, $body)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling updateCampaign'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling updateCampaign'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateCampaign'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCampaignSet
     *
     * Update a Campaign Set
     *
     * @param  int $application_id application_id (required)
     * @param  \TalonOne\Client\Model\NewCampaignSet $body body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\CampaignSet
     */
    public function updateCampaignSet($application_id, $body)
    {
        list($response) = $this->updateCampaignSetWithHttpInfo($application_id, $body);
        return $response;
    }

    /**
     * Operation updateCampaignSetWithHttpInfo
     *
     * Update a Campaign Set
     *
     * @param  int $application_id (required)
     * @param  \TalonOne\Client\Model\NewCampaignSet $body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\CampaignSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCampaignSetWithHttpInfo($application_id, $body)
    {
        $request = $this->updateCampaignSetRequest($application_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\CampaignSet' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\CampaignSet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\CampaignSet';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\CampaignSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateCampaignSetAsync
     *
     * Update a Campaign Set
     *
     * @param  int $application_id (required)
     * @param  \TalonOne\Client\Model\NewCampaignSet $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCampaignSetAsync($application_id, $body)
    {
        return $this->updateCampaignSetAsyncWithHttpInfo($application_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCampaignSetAsyncWithHttpInfo
     *
     * Update a Campaign Set
     *
     * @param  int $application_id (required)
     * @param  \TalonOne\Client\Model\NewCampaignSet $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCampaignSetAsyncWithHttpInfo($application_id, $body)
    {
        $returnType = '\TalonOne\Client\Model\CampaignSet';
        $request = $this->updateCampaignSetRequest($application_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCampaignSet'
     *
     * @param  int $application_id (required)
     * @param  \TalonOne\Client\Model\NewCampaignSet $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateCampaignSetRequest($application_id, $body)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling updateCampaignSet'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateCampaignSet'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaign_set';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCoupon
     *
     * Update a Coupon
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  string $coupon_id The ID of the coupon code to update (required)
     * @param  \TalonOne\Client\Model\UpdateCoupon $body body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\Coupon
     */
    public function updateCoupon($application_id, $campaign_id, $coupon_id, $body)
    {
        list($response) = $this->updateCouponWithHttpInfo($application_id, $campaign_id, $coupon_id, $body);
        return $response;
    }

    /**
     * Operation updateCouponWithHttpInfo
     *
     * Update a Coupon
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  string $coupon_id The ID of the coupon code to update (required)
     * @param  \TalonOne\Client\Model\UpdateCoupon $body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\Coupon, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCouponWithHttpInfo($application_id, $campaign_id, $coupon_id, $body)
    {
        $request = $this->updateCouponRequest($application_id, $campaign_id, $coupon_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\Coupon' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\Coupon', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\Coupon';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\Coupon',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateCouponAsync
     *
     * Update a Coupon
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  string $coupon_id The ID of the coupon code to update (required)
     * @param  \TalonOne\Client\Model\UpdateCoupon $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCouponAsync($application_id, $campaign_id, $coupon_id, $body)
    {
        return $this->updateCouponAsyncWithHttpInfo($application_id, $campaign_id, $coupon_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCouponAsyncWithHttpInfo
     *
     * Update a Coupon
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  string $coupon_id The ID of the coupon code to update (required)
     * @param  \TalonOne\Client\Model\UpdateCoupon $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCouponAsyncWithHttpInfo($application_id, $campaign_id, $coupon_id, $body)
    {
        $returnType = '\TalonOne\Client\Model\Coupon';
        $request = $this->updateCouponRequest($application_id, $campaign_id, $coupon_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCoupon'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  string $coupon_id The ID of the coupon code to update (required)
     * @param  \TalonOne\Client\Model\UpdateCoupon $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateCouponRequest($application_id, $campaign_id, $coupon_id, $body)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling updateCoupon'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling updateCoupon'
            );
        }
        // verify the required parameter 'coupon_id' is set
        if ($coupon_id === null || (is_array($coupon_id) && count($coupon_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $coupon_id when calling updateCoupon'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateCoupon'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons/{couponId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }
        // path params
        if ($coupon_id !== null) {
            $resourcePath = str_replace(
                '{' . 'couponId' . '}',
                ObjectSerializer::toPathValue($coupon_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCouponBatch
     *
     * Update a Batch of Coupons
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  \TalonOne\Client\Model\UpdateCouponBatch $body body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateCouponBatch($application_id, $campaign_id, $body)
    {
        $this->updateCouponBatchWithHttpInfo($application_id, $campaign_id, $body);
    }

    /**
     * Operation updateCouponBatchWithHttpInfo
     *
     * Update a Batch of Coupons
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\UpdateCouponBatch $body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCouponBatchWithHttpInfo($application_id, $campaign_id, $body)
    {
        $request = $this->updateCouponBatchRequest($application_id, $campaign_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateCouponBatchAsync
     *
     * Update a Batch of Coupons
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\UpdateCouponBatch $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCouponBatchAsync($application_id, $campaign_id, $body)
    {
        return $this->updateCouponBatchAsyncWithHttpInfo($application_id, $campaign_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCouponBatchAsyncWithHttpInfo
     *
     * Update a Batch of Coupons
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\UpdateCouponBatch $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCouponBatchAsyncWithHttpInfo($application_id, $campaign_id, $body)
    {
        $returnType = '';
        $request = $this->updateCouponBatchRequest($application_id, $campaign_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCouponBatch'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  \TalonOne\Client\Model\UpdateCouponBatch $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateCouponBatchRequest($application_id, $campaign_id, $body)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling updateCouponBatch'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling updateCouponBatch'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateCouponBatch'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateRuleset
     *
     * Update a Ruleset
     *
     * @param  int $application_id application_id (required)
     * @param  int $campaign_id campaign_id (required)
     * @param  int $ruleset_id ruleset_id (required)
     * @param  \TalonOne\Client\Model\NewRuleset $body body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TalonOne\Client\Model\Ruleset
     */
    public function updateRuleset($application_id, $campaign_id, $ruleset_id, $body)
    {
        list($response) = $this->updateRulesetWithHttpInfo($application_id, $campaign_id, $ruleset_id, $body);
        return $response;
    }

    /**
     * Operation updateRulesetWithHttpInfo
     *
     * Update a Ruleset
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $ruleset_id (required)
     * @param  \TalonOne\Client\Model\NewRuleset $body (required)
     *
     * @throws \TalonOne\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TalonOne\Client\Model\Ruleset, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateRulesetWithHttpInfo($application_id, $campaign_id, $ruleset_id, $body)
    {
        $request = $this->updateRulesetRequest($application_id, $campaign_id, $ruleset_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\TalonOne\Client\Model\Ruleset' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TalonOne\Client\Model\Ruleset', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\TalonOne\Client\Model\Ruleset';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TalonOne\Client\Model\Ruleset',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateRulesetAsync
     *
     * Update a Ruleset
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $ruleset_id (required)
     * @param  \TalonOne\Client\Model\NewRuleset $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateRulesetAsync($application_id, $campaign_id, $ruleset_id, $body)
    {
        return $this->updateRulesetAsyncWithHttpInfo($application_id, $campaign_id, $ruleset_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateRulesetAsyncWithHttpInfo
     *
     * Update a Ruleset
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $ruleset_id (required)
     * @param  \TalonOne\Client\Model\NewRuleset $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateRulesetAsyncWithHttpInfo($application_id, $campaign_id, $ruleset_id, $body)
    {
        $returnType = '\TalonOne\Client\Model\Ruleset';
        $request = $this->updateRulesetRequest($application_id, $campaign_id, $ruleset_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateRuleset'
     *
     * @param  int $application_id (required)
     * @param  int $campaign_id (required)
     * @param  int $ruleset_id (required)
     * @param  \TalonOne\Client\Model\NewRuleset $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateRulesetRequest($application_id, $campaign_id, $ruleset_id, $body)
    {
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling updateRuleset'
            );
        }
        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling updateRuleset'
            );
        }
        // verify the required parameter 'ruleset_id' is set
        if ($ruleset_id === null || (is_array($ruleset_id) && count($ruleset_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ruleset_id when calling updateRuleset'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateRuleset'
            );
        }

        $resourcePath = '/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets/{rulesetId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }
        // path params
        if ($ruleset_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rulesetId' . '}',
                ObjectSerializer::toPathValue($ruleset_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
